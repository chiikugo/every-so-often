{"ast":null,"code":"/*!\n* KUTE.js Standard v2.2.4 (http://thednp.github.io/kute.js)\n* Copyright 2015-2022 Â© thednp\n* Licensed under MIT (https://github.com/thednp/kute.js/blob/master/LICENSE)\n*/\n/**\r\n * Creates cubic-bezier easing functions for animation engines.\r\n * @see http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h\r\n * \r\n *\r\n * @class\r\n */\nclass CubicBezier {\n  /**\r\n   * @constructor\r\n   * @param {number} x1 - first point horizontal position\r\n   * @param {number} y1 - first point vertical position\r\n   * @param {number} x2 - second point horizontal position\r\n   * @param {number} y2 - second point vertical position\r\n   * @param {string=} functionName - an optional function name\r\n   * @returns {(t: number) => number} a new CubicBezier easing function\r\n   */\n  constructor(x1, y1, x2, y2, functionName) {\n    // pre-calculate the polynomial coefficients\n    // First and last control points are implied to be (0.0, 0.0) and (1.0, 1.0)\n    const p1x = x1 || 0;\n    const p1y = y1 || 0;\n    const p2x = x2 || 1;\n    const p2y = y2 || 1;\n\n    /** @type {number} */\n    this.cx = 3 * p1x;\n\n    /** @type {number} */\n    this.bx = 3 * (p2x - p1x) - this.cx;\n\n    /** @type {number} */\n    this.ax = 1 - this.cx - this.bx;\n\n    /** @type {number} */\n    this.cy = 3 * p1y;\n\n    /** @type {number} */\n    this.by = 3 * (p2y - p1y) - this.cy;\n\n    /** @type {number} */\n    this.ay = 1 - this.cy - this.by;\n\n    /** @type {(t: number) => number} */\n    const BezierEasing = t => this.sampleCurveY(this.solveCurveX(t));\n\n    // this function needs a name\n    Object.defineProperty(BezierEasing, 'name', {\n      writable: true\n    });\n    BezierEasing.name = functionName || `cubic-bezier(${[p1x, p1y, p2x, p2y]})`;\n    return BezierEasing;\n  }\n\n  /**\r\n   * @param {number} t - progress [0-1]\r\n   * @return {number} - sampled X value\r\n   */\n  sampleCurveX(t) {\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n  }\n\n  /**\r\n   * @param {number} t - progress [0-1]\r\n   * @return {number} - sampled Y value\r\n   */\n  sampleCurveY(t) {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n  }\n\n  /**\r\n   * @param {number} t - progress [0-1]\r\n   * @return {number} - sampled curve derivative X value\r\n   */\n  sampleCurveDerivativeX(t) {\n    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n  }\n\n  /**\r\n   * @param {number} x - progress [0-1]\r\n   * @return {number} - solved curve X value\r\n   */\n  solveCurveX(x) {\n    // Set Precision\n    const epsilon = 1e-6;\n\n    // Skip values out of range\n    if (x <= 0) return 0;\n    if (x >= 1) return 1;\n    let t2 = x;\n    let x2 = 0;\n    let d2 = 0;\n\n    // First try a few iterations of Newton's method\n    // -- usually very fast.\n    for (let i = 0; i < 8; i += 1) {\n      x2 = this.sampleCurveX(t2) - x;\n      if (Math.abs(x2) < epsilon) return t2;\n      d2 = this.sampleCurveDerivativeX(t2);\n      /* istanbul ignore next */\n      if (Math.abs(d2) < epsilon) break;\n      t2 -= x2 / d2;\n    }\n\n    // No solution found - use bi-section\n    let t0 = 0;\n    let t1 = 1;\n    t2 = x;\n    while (t0 < t1) {\n      x2 = this.sampleCurveX(t2);\n      if (Math.abs(x2 - x) < epsilon) return t2;\n      if (x > x2) t0 = t2;else t1 = t2;\n      t2 = (t1 - t0) * 0.5 + t0;\n    }\n\n    // Give up\n    /* istanbul ignore next */\n    return t2;\n  }\n}\nvar version$1 = \"1.0.1\";\n\n/**\r\n * A global namespace for library version.\r\n * @type {string}\r\n */\nconst Version$1 = version$1;\n\n/** @typedef {import('../types/index')} */\n\nObject.assign(CubicBezier, {\n  Version: Version$1\n});\n\n/**\n * The KUTE.js Execution Context\n */\nconst KEC = {};\nconst Tweens = [];\nlet gl0bal;\nif (typeof global !== 'undefined') gl0bal = global;else if (typeof window !== 'undefined') gl0bal = window.self;else gl0bal = {};\nconst globalObject = gl0bal;\n\n// KUTE.js INTERPOLATE FUNCTIONS\n// =============================\nconst interpolate = {};\n\n// schedule property specific function on animation start\n// link property update function to KUTE.js execution context\nconst onStart = {};\n\n// Include a performance.now polyfill.\n// source https://github.com/tweenjs/tween.js/blob/master/src/Now.ts\nlet performanceNow;\n\n// In node.js, use process.hrtime.\n// eslint-disable-next-line\n// @ts-ignore\nif (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {\n  performanceNow = () => {\n    // eslint-disable-next-line\n    // @ts-ignore\n    const time = process.hrtime();\n\n    // Convert [seconds, nanoseconds] to milliseconds.\n    return time[0] * 1000 + time[1] / 1000000;\n  };\n} else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {\n  // In a browser, use self.performance.now if it is available.\n  // This must be bound, because directly assigning this function\n  // leads to an invocation exception in Chrome.\n  performanceNow = self.performance.now.bind(self.performance);\n} else if (typeof Date !== 'undefined' && Date.now) {\n  // Use Date.now if it is available.\n  performanceNow = Date.now;\n} else {\n  // Otherwise, use 'new Date().getTime()'.\n  performanceNow = () => new Date().getTime();\n}\nconst now = performanceNow;\nconst Time = {};\nTime.now = now;\n\n// eslint-disable-next-line import/no-mutable-exports -- impossible to satisfy\nlet Tick = 0;\n\n/**\n *\n * @param {number | Date} time\n */\nconst Ticker = time => {\n  let i = 0;\n  while (i < Tweens.length) {\n    if (Tweens[i].update(time)) {\n      i += 1;\n    } else {\n      Tweens.splice(i, 1);\n    }\n  }\n  Tick = requestAnimationFrame(Ticker);\n};\n\n// stop requesting animation frame\nfunction stop() {\n  setTimeout(() => {\n    // re-added for #81\n    if (!Tweens.length && Tick) {\n      cancelAnimationFrame(Tick);\n      Tick = null;\n      Object.keys(onStart).forEach(obj => {\n        if (typeof onStart[obj] === 'function') {\n          if (KEC[obj]) delete KEC[obj];\n        } else {\n          Object.keys(onStart[obj]).forEach(prop => {\n            if (KEC[prop]) delete KEC[prop];\n          });\n        }\n      });\n      Object.keys(interpolate).forEach(i => {\n        if (KEC[i]) delete KEC[i];\n      });\n    }\n  }, 64);\n}\n\n// render update functions\n// =======================\nconst Render = {\n  Tick,\n  Ticker,\n  Tweens,\n  Time\n};\nObject.keys(Render).forEach(blob => {\n  if (!KEC[blob]) {\n    KEC[blob] = blob === 'Time' ? Time.now : Render[blob];\n  }\n});\nglobalObject._KUTE = KEC;\n\n// all supported properties\nconst supportedProperties = {};\nconst defaultValues = {};\nconst defaultOptions$1 = {\n  duration: 700,\n  delay: 0,\n  easing: 'linear',\n  repeat: 0,\n  repeatDelay: 0,\n  yoyo: false,\n  resetStart: false,\n  offset: 0\n};\n\n// used in preparePropertiesObject\nconst prepareProperty = {};\n\n// check current property value when .to() method is used\nconst prepareStart = {};\n\n// checks for differences between the processed start and end values,\n// can be set to make sure start unit and end unit are same,\n// stack transforms, process SVG paths,\n// any type of post processing the component needs\nconst crossCheck = {};\n\n// schedule property specific function on animation complete\nconst onComplete = {};\n\n// link properties to interpolate functions\nconst linkProperty = {};\nconst Objects = {\n  supportedProperties,\n  defaultValues,\n  defaultOptions: defaultOptions$1,\n  prepareProperty,\n  prepareStart,\n  crossCheck,\n  onStart,\n  onComplete,\n  linkProperty\n};\n\n// util - a general object for utils like rgbToHex, processEasing\nconst Util = {};\n\n/**\n * KUTE.add(Tween)\n *\n * @param {KUTE.Tween} tw a new tween to add\n */\nconst add = tw => Tweens.push(tw);\n\n/**\n * KUTE.remove(Tween)\n *\n * @param {KUTE.Tween} tw a new tween to add\n */\nconst remove = tw => {\n  const i = Tweens.indexOf(tw);\n  if (i !== -1) Tweens.splice(i, 1);\n};\n\n/**\n * KUTE.add(Tween)\n *\n * @return {KUTE.Tween[]} tw a new tween to add\n */\nconst getAll = () => Tweens;\n\n/**\n * KUTE.removeAll()\n */\nconst removeAll = () => {\n  Tweens.length = 0;\n};\n\n/**\n * linkInterpolation\n * @this {KUTE.Tween}\n */\nfunction linkInterpolation() {\n  // DON'T change\n  Object.keys(linkProperty).forEach(component => {\n    const componentLink = linkProperty[component];\n    const componentProps = supportedProperties[component];\n    Object.keys(componentLink).forEach(fnObj => {\n      if (typeof componentLink[fnObj] === 'function' // ATTR, colors, scroll, boxModel, borderRadius\n      && Object.keys(this.valuesEnd).some(i => componentProps && componentProps.includes(i) || i === 'attr' && Object.keys(this.valuesEnd[i]).some(j => componentProps && componentProps.includes(j)))) {\n        if (!KEC[fnObj]) KEC[fnObj] = componentLink[fnObj];\n      } else {\n        Object.keys(this.valuesEnd).forEach(prop => {\n          const propObject = this.valuesEnd[prop];\n          if (propObject instanceof Object) {\n            Object.keys(propObject).forEach(i => {\n              if (typeof componentLink[i] === 'function') {\n                // transformCSS3\n                if (!KEC[i]) KEC[i] = componentLink[i];\n              } else {\n                Object.keys(componentLink[fnObj]).forEach(j => {\n                  if (componentLink[i] && typeof componentLink[i][j] === 'function') {\n                    // transformMatrix\n                    if (!KEC[j]) KEC[j] = componentLink[i][j];\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n  });\n}\nconst internals = {\n  add,\n  remove,\n  getAll,\n  removeAll,\n  stop,\n  linkInterpolation\n};\n\n/**\n * getInlineStyle\n * Returns the transform style for element from\n * cssText. Used by for the `.to()` static method.\n *\n * @param {Element} el target element\n * @returns {object}\n */\nfunction getInlineStyle(el) {\n  // if the scroll applies to `window` it returns as it has no styling\n  if (!el.style) return false;\n  // the cssText | the resulting transform object\n  const css = el.style.cssText.replace(/\\s/g, '').split(';');\n  const transformObject = {};\n  const arrayFn = ['translate3d', 'translate', 'scale3d', 'skew'];\n  css.forEach(cs => {\n    if (/transform/i.test(cs)) {\n      // all transform properties\n      const tps = cs.split(':')[1].split(')');\n      tps.forEach(tpi => {\n        const tpv = tpi.split('(');\n        const tp = tpv[0];\n        // each transform property\n        const tv = tpv[1];\n        if (!/matrix/.test(tp)) {\n          transformObject[tp] = arrayFn.includes(tp) ? tv.split(',') : tv;\n        }\n      });\n    }\n  });\n  return transformObject;\n}\n\n/**\n * getStyleForProperty\n *\n * Returns the computed style property for element for .to() method.\n * Used by for the `.to()` static method.\n *\n * @param {Element} elem\n * @param {string} propertyName\n * @returns {string}\n */\nfunction getStyleForProperty(elem, propertyName) {\n  let result = defaultValues[propertyName];\n  const styleAttribute = elem.style;\n  const computedStyle = getComputedStyle(elem) || elem.currentStyle;\n  const styleValue = styleAttribute[propertyName] && !/auto|initial|none|unset/.test(styleAttribute[propertyName]) ? styleAttribute[propertyName] : computedStyle[propertyName];\n  if (propertyName !== 'transform' && (propertyName in computedStyle || propertyName in styleAttribute)) {\n    result = styleValue;\n  }\n  return result;\n}\n\n/**\n * prepareObject\n *\n * Returns all processed valuesStart / valuesEnd.\n *\n * @param {Element} obj the values start/end object\n * @param {string} fn toggles between the two\n */\nfunction prepareObject(obj, fn) {\n  // this, props object, type: start/end\n  const propertiesObject = fn === 'start' ? this.valuesStart : this.valuesEnd;\n  Object.keys(prepareProperty).forEach(component => {\n    const prepareComponent = prepareProperty[component];\n    const supportComponent = supportedProperties[component];\n    Object.keys(prepareComponent).forEach(tweenCategory => {\n      const transformObject = {};\n      Object.keys(obj).forEach(tweenProp => {\n        // scroll, opacity, other components\n        if (defaultValues[tweenProp] && prepareComponent[tweenProp]) {\n          propertiesObject[tweenProp] = prepareComponent[tweenProp].call(this, tweenProp, obj[tweenProp]);\n\n          // transform\n        } else if (!defaultValues[tweenCategory] && tweenCategory === 'transform' && supportComponent.includes(tweenProp)) {\n          transformObject[tweenProp] = obj[tweenProp];\n\n          // allow transformFunctions to work with preprocessed input values\n        } else if (!defaultValues[tweenProp] && tweenProp === 'transform') {\n          propertiesObject[tweenProp] = obj[tweenProp];\n\n          // colors, boxModel, category\n        } else if (!defaultValues[tweenCategory] && supportComponent && supportComponent.includes(tweenProp)) {\n          propertiesObject[tweenProp] = prepareComponent[tweenCategory].call(this, tweenProp, obj[tweenProp]);\n        }\n      });\n\n      // we filter out older browsers by checking Object.keys\n      if (Object.keys(transformObject).length) {\n        propertiesObject[tweenCategory] = prepareComponent[tweenCategory].call(this, tweenCategory, transformObject);\n      }\n    });\n  });\n}\n\n/**\n * getStartValues\n *\n * Returns the start values for to() method.\n * Used by for the `.to()` static method.\n *\n * @this {KUTE.Tween} the tween instance\n */\nfunction getStartValues() {\n  const startValues = {};\n  const currentStyle = getInlineStyle(this.element);\n  Object.keys(this.valuesStart).forEach(tweenProp => {\n    Object.keys(prepareStart).forEach(component => {\n      const componentStart = prepareStart[component];\n      Object.keys(componentStart).forEach(tweenCategory => {\n        // clip, opacity, scroll\n        if (tweenCategory === tweenProp && componentStart[tweenProp]) {\n          startValues[tweenProp] = componentStart[tweenCategory].call(this, tweenProp, this.valuesStart[tweenProp]);\n          // find in an array of properties\n        } else if (supportedProperties[component] && supportedProperties[component].includes(tweenProp)) {\n          startValues[tweenProp] = componentStart[tweenCategory].call(this, tweenProp, this.valuesStart[tweenProp]);\n        }\n      });\n    });\n  });\n\n  // stack transformCSS props for .to() chains\n  // also add to startValues values from previous tweens\n  Object.keys(currentStyle).forEach(current => {\n    if (!(current in this.valuesStart)) {\n      startValues[current] = currentStyle[current] || defaultValues[current];\n    }\n  });\n  this.valuesStart = {};\n  prepareObject.call(this, startValues, 'start');\n}\nvar Process = {\n  getInlineStyle,\n  getStyleForProperty,\n  getStartValues,\n  prepareObject\n};\nconst connect = {};\n/** @type {KUTE.TweenBase | KUTE.Tween | KUTE.TweenExtra} */\nconnect.tween = null;\nconnect.processEasing = null;\nconst Easing = {\n  linear: new CubicBezier(0, 0, 1, 1, 'linear'),\n  easingSinusoidalIn: new CubicBezier(0.47, 0, 0.745, 0.715, 'easingSinusoidalIn'),\n  easingSinusoidalOut: new CubicBezier(0.39, 0.575, 0.565, 1, 'easingSinusoidalOut'),\n  easingSinusoidalInOut: new CubicBezier(0.445, 0.05, 0.55, 0.95, 'easingSinusoidalInOut'),\n  easingQuadraticIn: new CubicBezier(0.550, 0.085, 0.680, 0.530, 'easingQuadraticIn'),\n  easingQuadraticOut: new CubicBezier(0.250, 0.460, 0.450, 0.940, 'easingQuadraticOut'),\n  easingQuadraticInOut: new CubicBezier(0.455, 0.030, 0.515, 0.955, 'easingQuadraticInOut'),\n  easingCubicIn: new CubicBezier(0.55, 0.055, 0.675, 0.19, 'easingCubicIn'),\n  easingCubicOut: new CubicBezier(0.215, 0.61, 0.355, 1, 'easingCubicOut'),\n  easingCubicInOut: new CubicBezier(0.645, 0.045, 0.355, 1, 'easingCubicInOut'),\n  easingQuarticIn: new CubicBezier(0.895, 0.03, 0.685, 0.22, 'easingQuarticIn'),\n  easingQuarticOut: new CubicBezier(0.165, 0.84, 0.44, 1, 'easingQuarticOut'),\n  easingQuarticInOut: new CubicBezier(0.77, 0, 0.175, 1, 'easingQuarticInOut'),\n  easingQuinticIn: new CubicBezier(0.755, 0.05, 0.855, 0.06, 'easingQuinticIn'),\n  easingQuinticOut: new CubicBezier(0.23, 1, 0.32, 1, 'easingQuinticOut'),\n  easingQuinticInOut: new CubicBezier(0.86, 0, 0.07, 1, 'easingQuinticInOut'),\n  easingExponentialIn: new CubicBezier(0.95, 0.05, 0.795, 0.035, 'easingExponentialIn'),\n  easingExponentialOut: new CubicBezier(0.19, 1, 0.22, 1, 'easingExponentialOut'),\n  easingExponentialInOut: new CubicBezier(1, 0, 0, 1, 'easingExponentialInOut'),\n  easingCircularIn: new CubicBezier(0.6, 0.04, 0.98, 0.335, 'easingCircularIn'),\n  easingCircularOut: new CubicBezier(0.075, 0.82, 0.165, 1, 'easingCircularOut'),\n  easingCircularInOut: new CubicBezier(0.785, 0.135, 0.15, 0.86, 'easingCircularInOut'),\n  easingBackIn: new CubicBezier(0.6, -0.28, 0.735, 0.045, 'easingBackIn'),\n  easingBackOut: new CubicBezier(0.175, 0.885, 0.32, 1.275, 'easingBackOut'),\n  easingBackInOut: new CubicBezier(0.68, -0.55, 0.265, 1.55, 'easingBackInOut')\n};\n\n/**\n * Returns a valid `easingFunction`.\n *\n * @param {KUTE.easingFunction | string} fn function name or constructor name\n * @returns {KUTE.easingFunction} a valid easingfunction\n */\nfunction processBezierEasing(fn) {\n  if (typeof fn === 'function') {\n    return fn;\n  }\n  if (typeof Easing[fn] === 'function') {\n    return Easing[fn];\n  }\n  if (/bezier/.test(fn)) {\n    const bz = fn.replace(/bezier|\\s|\\(|\\)/g, '').split(',');\n    return new CubicBezier(bz[0] * 1, bz[1] * 1, bz[2] * 1, bz[3] * 1); // bezier easing\n  }\n  // if (/elastic|bounce/i.test(fn)) {\n  //   throw TypeError(`KUTE - CubicBezier doesn't support ${fn} easing.`);\n  // }\n  return Easing.linear;\n}\nconnect.processEasing = processBezierEasing;\n\n/**\n * selector\n *\n * A selector utility for KUTE.js.\n *\n * @param {KUTE.selectorType} el target(s) or string selector\n * @param {boolean | number} multi when true returns an array/collection of elements\n * @returns {Element | Element[] | null}\n */\nfunction selector(el, multi) {\n  try {\n    let requestedElem;\n    let itemsArray;\n    if (multi) {\n      itemsArray = el instanceof Array && el.every(x => x instanceof Element);\n      requestedElem = el instanceof HTMLCollection || el instanceof NodeList || itemsArray ? el : document.querySelectorAll(el);\n    } else {\n      requestedElem = el instanceof Element || el === window // scroll\n      ? el : document.querySelector(el);\n    }\n    return requestedElem;\n  } catch (e) {\n    throw TypeError(`KUTE.js - Element(s) not found: ${el}.`);\n  }\n}\nfunction queueStart() {\n  // fire onStart actions\n  Object.keys(onStart).forEach(obj => {\n    if (typeof onStart[obj] === 'function') {\n      onStart[obj].call(this, obj); // easing functions\n    } else {\n      Object.keys(onStart[obj]).forEach(prop => {\n        onStart[obj][prop].call(this, prop);\n      });\n    }\n  });\n\n  // add interpolations\n  linkInterpolation.call(this);\n}\n\n/**\n * The `TweenBase` constructor creates a new `Tween` object\n * for a single `HTMLElement` and returns it.\n *\n * `TweenBase` is meant to be used with pre-processed values.\n */\nclass TweenBase {\n  /**\n   * @param {Element} targetElement the target element\n   * @param {KUTE.tweenProps} startObject the start values\n   * @param {KUTE.tweenProps} endObject the end values\n   * @param {KUTE.tweenOptions} opsObject the end values\n   * @returns {TweenBase} the resulting Tween object\n   */\n  constructor(targetElement, startObject, endObject, opsObject) {\n    // element animation is applied to\n    this.element = targetElement;\n\n    /** @type {boolean} */\n    this.playing = false;\n    /** @type {number?} */\n    this._startTime = null;\n    /** @type {boolean} */\n    this._startFired = false;\n\n    // type is set via KUTE.tweenProps\n    this.valuesEnd = endObject;\n    this.valuesStart = startObject;\n\n    // OPTIONS\n    const options = opsObject || {};\n    // internal option to process inline/computed style at start instead of init\n    // used by to() method and expects object : {} / false\n    this._resetStart = options.resetStart || 0;\n    // you can only set a core easing function as default\n    /** @type {KUTE.easingOption} */\n    this._easing = typeof options.easing === 'function' ? options.easing : connect.processEasing(options.easing);\n    /** @type {number} */\n    this._duration = options.duration || defaultOptions$1.duration; // duration option | default\n    /** @type {number} */\n    this._delay = options.delay || defaultOptions$1.delay; // delay option | default\n\n    // set other options\n    Object.keys(options).forEach(op => {\n      const internalOption = `_${op}`;\n      if (!(internalOption in this)) this[internalOption] = options[op];\n    });\n\n    // callbacks should not be set as undefined\n    // this._onStart = options.onStart\n    // this._onUpdate = options.onUpdate\n    // this._onStop = options.onStop\n    // this._onComplete = options.onComplete\n\n    // queue the easing\n    const easingFnName = this._easing.name;\n    if (!onStart[easingFnName]) {\n      onStart[easingFnName] = function easingFn(prop) {\n        if (!KEC[prop] && prop === this._easing.name) KEC[prop] = this._easing;\n      };\n    }\n    return this;\n  }\n\n  /**\n   * Starts tweening\n   * @param {number?} time the tween start time\n   * @returns {TweenBase} this instance\n   */\n  start(time) {\n    // now it's a good time to start\n    add(this);\n    this.playing = true;\n    this._startTime = typeof time !== 'undefined' ? time : KEC.Time();\n    this._startTime += this._delay;\n    if (!this._startFired) {\n      if (this._onStart) {\n        this._onStart.call(this);\n      }\n      queueStart.call(this);\n      this._startFired = true;\n    }\n    if (!Tick) Ticker();\n    return this;\n  }\n\n  /**\n   * Stops tweening\n   * @returns {TweenBase} this instance\n   */\n  stop() {\n    if (this.playing) {\n      remove(this);\n      this.playing = false;\n      if (this._onStop) {\n        this._onStop.call(this);\n      }\n      this.close();\n    }\n    return this;\n  }\n\n  /**\n   * Trigger internal completion callbacks.\n   */\n  close() {\n    // scroll|transformMatrix need this\n    Object.keys(onComplete).forEach(component => {\n      Object.keys(onComplete[component]).forEach(toClose => {\n        onComplete[component][toClose].call(this, toClose);\n      });\n    });\n    // when all animations are finished, stop ticking after ~3 frames\n    this._startFired = false;\n    stop.call(this);\n  }\n\n  /**\n   * Schedule another tween instance to start once this one completes.\n   * @param {KUTE.chainOption} args the tween animation start time\n   * @returns {TweenBase} this instance\n   */\n  chain(args) {\n    this._chain = [];\n    this._chain = args.length ? args : this._chain.concat(args);\n    return this;\n  }\n\n  /**\n   * Stop tweening the chained tween instances.\n   */\n  stopChainedTweens() {\n    if (this._chain && this._chain.length) this._chain.forEach(tw => tw.stop());\n  }\n\n  /**\n   * Update the tween on each tick.\n   * @param {number} time the tick time\n   * @returns {boolean} this instance\n   */\n  update(time) {\n    const T = time !== undefined ? time : KEC.Time();\n    let elapsed;\n    if (T < this._startTime && this.playing) {\n      return true;\n    }\n    elapsed = (T - this._startTime) / this._duration;\n    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n\n    // calculate progress\n    const progress = this._easing(elapsed);\n\n    // render the update\n    Object.keys(this.valuesEnd).forEach(tweenProp => {\n      KEC[tweenProp](this.element, this.valuesStart[tweenProp], this.valuesEnd[tweenProp], progress);\n    });\n\n    // fire the updateCallback\n    if (this._onUpdate) {\n      this._onUpdate.call(this);\n    }\n    if (elapsed === 1) {\n      // fire the complete callback\n      if (this._onComplete) {\n        this._onComplete.call(this);\n      }\n\n      // now we're sure no animation is running\n      this.playing = false;\n\n      // stop ticking when finished\n      this.close();\n\n      // start animating chained tweens\n      if (this._chain !== undefined && this._chain.length) {\n        this._chain.map(tw => tw.start());\n      }\n      return false;\n    }\n    return true;\n  }\n}\n\n// Update Tween Interface\nconnect.tween = TweenBase;\n\n/**\n * The `KUTE.Tween()` constructor creates a new `Tween` object\n * for a single `HTMLElement` and returns it.\n *\n * This constructor adds additional functionality and is the default\n * Tween object constructor in KUTE.js.\n */\nclass Tween extends TweenBase {\n  /**\n   * @param {KUTE.tweenParams} args (*target*, *startValues*, *endValues*, *options*)\n   * @returns {Tween} the resulting Tween object\n   */\n  constructor(...args) {\n    super(...args); // this calls the constructor of TweenBase\n\n    // reset interpolation values\n    this.valuesStart = {};\n    this.valuesEnd = {};\n\n    // const startObject = args[1];\n    // const endObject = args[2];\n    const [startObject, endObject, options] = args.slice(1);\n\n    // set valuesEnd\n    prepareObject.call(this, endObject, 'end');\n\n    // set valuesStart\n    if (this._resetStart) {\n      this.valuesStart = startObject;\n    } else {\n      prepareObject.call(this, startObject, 'start');\n    }\n\n    // ready for crossCheck\n    if (!this._resetStart) {\n      Object.keys(crossCheck).forEach(component => {\n        Object.keys(crossCheck[component]).forEach(checkProp => {\n          crossCheck[component][checkProp].call(this, checkProp);\n        });\n      });\n    }\n\n    // set paused state\n    /** @type {boolean} */\n    this.paused = false;\n    /** @type {number?} */\n    this._pauseTime = null;\n\n    // additional properties and options\n    /** @type {number?} */\n    this._repeat = options.repeat || defaultOptions$1.repeat;\n    /** @type {number?} */\n    this._repeatDelay = options.repeatDelay || defaultOptions$1.repeatDelay;\n    // we cache the number of repeats to be able to put it back after all cycles finish\n    /** @type {number?} */\n    this._repeatOption = this._repeat;\n\n    // yoyo needs at least repeat: 1\n    /** @type {KUTE.tweenProps} */\n    this.valuesRepeat = {}; // valuesRepeat\n    /** @type {boolean} */\n    this._yoyo = options.yoyo || defaultOptions$1.yoyo;\n    /** @type {boolean} */\n    this._reversed = false;\n\n    // don't load extra callbacks\n    // this._onPause = options.onPause || defaultOptions.onPause\n    // this._onResume = options.onResume || defaultOptions.onResume\n\n    // chained Tweens\n    // this._chain = options.chain || defaultOptions.chain;\n    return this;\n  }\n\n  /**\n   * Starts tweening, extended method\n   * @param {number?} time the tween start time\n   * @returns {Tween} this instance\n   */\n  start(time) {\n    // on start we reprocess the valuesStart for TO() method\n    if (this._resetStart) {\n      this.valuesStart = this._resetStart;\n      getStartValues.call(this);\n\n      // this is where we do the valuesStart and valuesEnd check for fromTo() method\n      Object.keys(crossCheck).forEach(component => {\n        Object.keys(crossCheck[component]).forEach(checkProp => {\n          crossCheck[component][checkProp].call(this, checkProp);\n        });\n      });\n    }\n    // still not paused\n    this.paused = false;\n\n    // set yoyo values\n    if (this._yoyo) {\n      Object.keys(this.valuesEnd).forEach(endProp => {\n        this.valuesRepeat[endProp] = this.valuesStart[endProp];\n      });\n    }\n    super.start(time);\n    return this;\n  }\n\n  /**\n   * Stops tweening, extended method\n   * @returns {Tween} this instance\n   */\n  stop() {\n    super.stop();\n    if (!this.paused && this.playing) {\n      this.paused = false;\n      this.stopChainedTweens();\n    }\n    return this;\n  }\n\n  /**\n   * Trigger internal completion callbacks.\n   */\n  close() {\n    super.close();\n    if (this._repeatOption > 0) {\n      this._repeat = this._repeatOption;\n    }\n    if (this._yoyo && this._reversed === true) {\n      this.reverse();\n      this._reversed = false;\n    }\n    return this;\n  }\n\n  /**\n   * Resume tweening\n   * @returns {Tween} this instance\n   */\n  resume() {\n    if (this.paused && this.playing) {\n      this.paused = false;\n      if (this._onResume !== undefined) {\n        this._onResume.call(this);\n      }\n      // re-queue execution context\n      queueStart.call(this);\n      // update time and let it roll\n      this._startTime += KEC.Time() - this._pauseTime;\n      add(this);\n      // restart ticker if stopped\n      if (!Tick) Ticker();\n    }\n    return this;\n  }\n\n  /**\n   * Pause tweening\n   * @returns {Tween} this instance\n   */\n  pause() {\n    if (!this.paused && this.playing) {\n      remove(this);\n      this.paused = true;\n      this._pauseTime = KEC.Time();\n      if (this._onPause !== undefined) {\n        this._onPause.call(this);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Reverses start values with end values\n   */\n  reverse() {\n    Object.keys(this.valuesEnd).forEach(reverseProp => {\n      const tmp = this.valuesRepeat[reverseProp];\n      this.valuesRepeat[reverseProp] = this.valuesEnd[reverseProp];\n      this.valuesEnd[reverseProp] = tmp;\n      this.valuesStart[reverseProp] = this.valuesRepeat[reverseProp];\n    });\n  }\n\n  /**\n   * Update the tween on each tick.\n   * @param {number} time the tick time\n   * @returns {boolean} this instance\n   */\n  update(time) {\n    const T = time !== undefined ? time : KEC.Time();\n    let elapsed;\n    if (T < this._startTime && this.playing) {\n      return true;\n    }\n    elapsed = (T - this._startTime) / this._duration;\n    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n\n    // calculate progress\n    const progress = this._easing(elapsed);\n\n    // render the update\n    Object.keys(this.valuesEnd).forEach(tweenProp => {\n      KEC[tweenProp](this.element, this.valuesStart[tweenProp], this.valuesEnd[tweenProp], progress);\n    });\n\n    // fire the updateCallback\n    if (this._onUpdate) {\n      this._onUpdate.call(this);\n    }\n    if (elapsed === 1) {\n      if (this._repeat > 0) {\n        if (Number.isFinite(this._repeat)) this._repeat -= 1;\n\n        // set the right time for delay\n        this._startTime = T;\n        if (Number.isFinite(this._repeat) && this._yoyo && !this._reversed) {\n          this._startTime += this._repeatDelay;\n        }\n        if (this._yoyo) {\n          // handle yoyo\n          this._reversed = !this._reversed;\n          this.reverse();\n        }\n        return true;\n      }\n\n      // fire the complete callback\n      if (this._onComplete) {\n        this._onComplete.call(this);\n      }\n\n      // now we're sure no animation is running\n      this.playing = false;\n\n      // stop ticking when finished\n      this.close();\n\n      // start animating chained tweens\n      if (this._chain !== undefined && this._chain.length) {\n        this._chain.forEach(tw => tw.start());\n      }\n      return false;\n    }\n    return true;\n  }\n}\n\n// Update Tween Interface Update\nconnect.tween = Tween;\n\n/**\n * The static method creates a new `Tween` object for each `HTMLElement`\n * from and `Array`, `HTMLCollection` or `NodeList`.\n */\nclass TweenCollection {\n  /**\n   *\n   * @param {Element[] | HTMLCollection | NodeList} els target elements\n   * @param {KUTE.tweenProps} vS the start values\n   * @param {KUTE.tweenProps} vE the end values\n   * @param {KUTE.tweenOptions} Options tween options\n   * @returns {TweenCollection} the Tween object collection\n   */\n  constructor(els, vS, vE, Options) {\n    const TweenConstructor = connect.tween;\n    /** @type {KUTE.twCollection[]} */\n    this.tweens = [];\n    const Ops = Options || {};\n    /** @type {number?} */\n    Ops.delay = Ops.delay || defaultOptions$1.delay;\n\n    // set all options\n    const options = [];\n    Array.from(els).forEach((el, i) => {\n      options[i] = Ops || {};\n      options[i].delay = i > 0 ? Ops.delay + (Ops.offset || defaultOptions$1.offset) : Ops.delay;\n      if (el instanceof Element) {\n        this.tweens.push(new TweenConstructor(el, vS, vE, options[i]));\n      } else {\n        throw Error(`KUTE - ${el} is not instanceof Element`);\n      }\n    });\n\n    /** @type {number?} */\n    this.length = this.tweens.length;\n    return this;\n  }\n\n  /**\n   * Starts tweening, all targets\n   * @param {number?} time the tween start time\n   * @returns {TweenCollection} this instance\n   */\n  start(time) {\n    const T = time === undefined ? KEC.Time() : time;\n    this.tweens.map(tween => tween.start(T));\n    return this;\n  }\n\n  /**\n   * Stops tweening, all targets and their chains\n   * @returns {TweenCollection} this instance\n   */\n  stop() {\n    this.tweens.map(tween => tween.stop());\n    return this;\n  }\n\n  /**\n   * Pause tweening, all targets\n   * @returns {TweenCollection} this instance\n   */\n  pause() {\n    this.tweens.map(tween => tween.pause());\n    return this;\n  }\n\n  /**\n   * Resume tweening, all targets\n   * @returns {TweenCollection} this instance\n   */\n  resume() {\n    this.tweens.map(tween => tween.resume());\n    return this;\n  }\n\n  /**\n   * Schedule another tween or collection to start after\n   * this one is complete.\n   * @param {number?} args the tween start time\n   * @returns {TweenCollection} this instance\n   */\n  chain(args) {\n    const lastTween = this.tweens[this.length - 1];\n    if (args instanceof TweenCollection) {\n      lastTween.chain(args.tweens);\n    } else if (args instanceof connect.tween) {\n      lastTween.chain(args);\n    } else {\n      throw new TypeError('KUTE.js - invalid chain value');\n    }\n    return this;\n  }\n\n  /**\n   * Check if any tween instance is playing\n   * @param {number?} time the tween start time\n   * @returns {TweenCollection} this instance\n   */\n  playing() {\n    return this.tweens.some(tw => tw.playing);\n  }\n\n  /**\n   * Remove all tweens in the collection\n   */\n  removeTweens() {\n    this.tweens = [];\n  }\n\n  /**\n   * Returns the maximum animation duration\n   * @returns {number} this instance\n   */\n  getMaxDuration() {\n    const durations = [];\n    this.tweens.forEach(tw => {\n      durations.push(tw._duration + tw._delay + tw._repeat * tw._repeatDelay);\n    });\n    return Math.max(durations);\n  }\n}\nconst {\n  tween: TweenConstructor$1\n} = connect;\n\n/**\n * The `KUTE.to()` static method returns a new Tween object\n * for a single `HTMLElement` at its current state.\n *\n * @param {Element} element target element\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenOptions} optionsObj tween options\n * @returns {KUTE.Tween} the resulting Tween object\n */\nfunction to(element, endObject, optionsObj) {\n  const options = optionsObj || {};\n  options.resetStart = endObject;\n  return new TweenConstructor$1(selector(element), endObject, endObject, options);\n}\nconst {\n  tween: TweenConstructor\n} = connect;\n\n/**\n * The `KUTE.fromTo()` static method returns a new Tween object\n * for a single `HTMLElement` at a given state.\n *\n * @param {Element} element target element\n * @param {KUTE.tweenProps} startObject\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenOptions} optionsObj tween options\n * @returns {KUTE.Tween} the resulting Tween object\n */\nfunction fromTo(element, startObject, endObject, optionsObj) {\n  const options = optionsObj || {};\n  return new TweenConstructor(selector(element), startObject, endObject, options);\n}\n\n/**\n * The `KUTE.allTo()` static method creates a new Tween object\n * for multiple `HTMLElement`s, `HTMLCollection` or `NodeListat`\n * at their current state.\n *\n * @param {Element[] | HTMLCollection | NodeList} elements target elements\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenProps} optionsObj progress\n * @returns {TweenCollection} the Tween object collection\n */\nfunction allTo(elements, endObject, optionsObj) {\n  const options = optionsObj || {};\n  options.resetStart = endObject;\n  return new TweenCollection(selector(elements, true), endObject, endObject, options);\n}\n\n/**\n * The `KUTE.allFromTo()` static method creates a new Tween object\n * for multiple `HTMLElement`s, `HTMLCollection` or `NodeListat`\n * at a given state.\n *\n * @param {Element[] | HTMLCollection | NodeList} elements target elements\n * @param {KUTE.tweenProps} startObject\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenOptions} optionsObj tween options\n * @returns {TweenCollection} the Tween object collection\n */\nfunction allFromTo(elements, startObject, endObject, optionsObj) {\n  const options = optionsObj || {};\n  return new TweenCollection(selector(elements, true), startObject, endObject, options);\n}\n\n/**\n * Animation Class\n *\n * Registers components by populating KUTE.js objects and makes sure\n * no duplicate component / property is allowed.\n */\nclass Animation {\n  /**\n   * @constructor\n   * @param {KUTE.fullComponent} Component\n   */\n  constructor(Component) {\n    try {\n      if (Component.component in supportedProperties) {\n        throw Error(`KUTE - ${Component.component} already registered`);\n      } else if (Component.property in defaultValues) {\n        throw Error(`KUTE - ${Component.property} already registered`);\n      }\n    } catch (e) {\n      throw Error(e);\n    }\n    const propertyInfo = this;\n    const ComponentName = Component.component;\n    // const Objects = { defaultValues, defaultOptions, Interpolate, linkProperty, Util }\n    const Functions = {\n      prepareProperty,\n      prepareStart,\n      onStart,\n      onComplete,\n      crossCheck\n    };\n    const Category = Component.category;\n    const Property = Component.property;\n    const Length = Component.properties && Component.properties.length || Component.subProperties && Component.subProperties.length;\n\n    // single property\n    // {property,defaultvalue,defaultOptions,Interpolate,functions}\n\n    // category colors, boxModel, borderRadius\n    // {category,properties,defaultvalues,defaultOptions,Interpolate,functions}\n\n    // property with multiple sub properties. Eg transform, filter\n    // {property,subProperties,defaultvalues,defaultOptions,Interpolate,functions}\n\n    // property with multiple sub properties. Eg htmlAttributes\n    // {category,subProperties,defaultvalues,defaultOptions,Interpolate,functions}\n\n    // set supported category/property\n    supportedProperties[ComponentName] = Component.properties || Component.subProperties || Component.property;\n\n    // set defaultValues\n    if ('defaultValue' in Component) {\n      // value 0 will invalidate\n      defaultValues[Property] = Component.defaultValue;\n\n      // minimal info\n      propertyInfo.supports = `${Property} property`;\n    } else if (Component.defaultValues) {\n      Object.keys(Component.defaultValues).forEach(dv => {\n        defaultValues[dv] = Component.defaultValues[dv];\n      });\n\n      // minimal info\n      propertyInfo.supports = `${Length || Property} ${Property || Category} properties`;\n    }\n\n    // set additional options\n    if (Component.defaultOptions) {\n      // Object.keys(Component.defaultOptions).forEach((op) => {\n      //   defaultOptions[op] = Component.defaultOptions[op];\n      // });\n      Object.assign(defaultOptions$1, Component.defaultOptions);\n    }\n\n    // set functions\n    if (Component.functions) {\n      Object.keys(Functions).forEach(fn => {\n        if (fn in Component.functions) {\n          if (typeof Component.functions[fn] === 'function') {\n            // if (!Functions[fn][ Category||Property ]) {\n            //   Functions[fn][ Category||Property ] = Component.functions[fn];\n            // }\n            if (!Functions[fn][ComponentName]) Functions[fn][ComponentName] = {};\n            if (!Functions[fn][ComponentName][Category || Property]) {\n              Functions[fn][ComponentName][Category || Property] = Component.functions[fn];\n            }\n          } else {\n            Object.keys(Component.functions[fn]).forEach(ofn => {\n              // !Functions[fn][ofn] && (Functions[fn][ofn] = Component.functions[fn][ofn])\n              if (!Functions[fn][ComponentName]) Functions[fn][ComponentName] = {};\n              if (!Functions[fn][ComponentName][ofn]) {\n                Functions[fn][ComponentName][ofn] = Component.functions[fn][ofn];\n              }\n            });\n          }\n        }\n      });\n    }\n\n    // set component interpolation functions\n    if (Component.Interpolate) {\n      Object.keys(Component.Interpolate).forEach(fni => {\n        const compIntObj = Component.Interpolate[fni];\n        if (typeof compIntObj === 'function' && !interpolate[fni]) {\n          interpolate[fni] = compIntObj;\n        } else {\n          Object.keys(compIntObj).forEach(sfn => {\n            if (typeof compIntObj[sfn] === 'function' && !interpolate[fni]) {\n              interpolate[fni] = compIntObj[sfn];\n            }\n          });\n        }\n      });\n      linkProperty[ComponentName] = Component.Interpolate;\n    }\n\n    // set component util\n    if (Component.Util) {\n      Object.keys(Component.Util).forEach(fnu => {\n        if (!Util[fnu]) Util[fnu] = Component.Util[fnu];\n      });\n    }\n    return propertyInfo;\n  }\n}\n\n/**\n * trueDimension\n *\n * Returns the string value of a specific CSS property converted into a nice\n * { v = value, u = unit } object.\n *\n * @param {string} dimValue the property string value\n * @param {boolean | number} isAngle sets the utility to investigate angles\n * @returns {{v: number, u: string}} the true {value, unit} tuple\n */\nconst trueDimension = (dimValue, isAngle) => {\n  const intValue = parseInt(dimValue, 10) || 0;\n  const mUnits = ['px', '%', 'deg', 'rad', 'em', 'rem', 'vh', 'vw'];\n  let theUnit;\n  for (let mIndex = 0; mIndex < mUnits.length; mIndex += 1) {\n    if (typeof dimValue === 'string' && dimValue.includes(mUnits[mIndex])) {\n      theUnit = mUnits[mIndex];\n      break;\n    }\n  }\n  if (theUnit === undefined) {\n    theUnit = isAngle ? 'deg' : 'px';\n  }\n  return {\n    v: intValue,\n    u: theUnit\n  };\n};\n\n/**\n * Numbers Interpolation Function.\n *\n * @param {number} a start value\n * @param {number} b end value\n * @param {number} v progress\n * @returns {number} the interpolated number\n */\nfunction numbers(a, b, v) {\n  const A = +a;\n  const B = b - a;\n  // a = +a; b -= a;\n  return A + B * v;\n}\n\n// Component Functions\n/**\n * Sets the update function for the property.\n * @param {string} tweenProp the property name\n */\nfunction boxModelOnStart(tweenProp) {\n  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      /* eslint-disable no-param-reassign -- impossible to satisfy */\n      /* eslint-disable no-bitwise -- impossible to satisfy */\n      elem.style[tweenProp] = `${v > 0.99 || v < 0.01 ? (numbers(a, b, v) * 10 >> 0) / 10 : numbers(a, b, v) >> 0}px`;\n      /* eslint-enable no-bitwise */\n      /* eslint-enable no-param-reassign */\n    };\n  }\n}\n\n// Component Functions\n/**\n * Returns the current property computed style.\n * @param {string} tweenProp the property name\n * @returns {string} computed style for property\n */\nfunction getBoxModel(tweenProp) {\n  return getStyleForProperty(this.element, tweenProp) || defaultValues[tweenProp];\n}\n\n/**\n * Returns the property tween object.\n * @param {string} tweenProp the property name\n * @param {string} value the property name\n * @returns {number} the property tween object\n */\nfunction prepareBoxModel(tweenProp, value) {\n  const boxValue = trueDimension(value);\n  const offsetProp = tweenProp === 'height' ? 'offsetHeight' : 'offsetWidth';\n  return boxValue.u === '%' ? boxValue.v * this.element[offsetProp] / 100 : boxValue.v;\n}\n\n// Component Base Props\nconst essentialBoxProps = ['top', 'left', 'width', 'height'];\nconst essentialBoxPropsValues = {\n  top: 0,\n  left: 0,\n  width: 0,\n  height: 0\n};\nconst essentialBoxOnStart = {};\nessentialBoxProps.forEach(x => {\n  essentialBoxOnStart[x] = boxModelOnStart;\n});\n\n// All Component Functions\nconst essentialBoxModelFunctions = {\n  prepareStart: getBoxModel,\n  prepareProperty: prepareBoxModel,\n  onStart: essentialBoxOnStart\n};\n\n// Component Essential\nconst BoxModelEssential = {\n  component: 'essentialBoxModel',\n  category: 'boxModel',\n  properties: essentialBoxProps,\n  defaultValues: essentialBoxPropsValues,\n  Interpolate: {\n    numbers\n  },\n  functions: essentialBoxModelFunctions,\n  Util: {\n    trueDimension\n  }\n};\n\n/**\n * hexToRGB\n *\n * Converts a #HEX color format into RGB\n * and returns a color object {r,g,b}.\n *\n * @param {string} hex the degree angle\n * @returns {KUTE.colorObject | null} the radian angle\n */\nconst hexToRGB = hex => {\n  // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n  const hexShorthand = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  const HEX = hex.replace(hexShorthand, (_, r, g, b) => r + r + g + g + b + b);\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(HEX);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n};\n\n/**\n * trueColor\n *\n * Transform any color to rgba()/rgb() and return a nice RGB(a) object.\n *\n * @param {string} colorString the color input\n * @returns {KUTE.colorObject} the {r,g,b,a} color object\n */\nconst trueColor = colorString => {\n  let result;\n  if (/rgb|rgba/.test(colorString)) {\n    // first check if it's a rgb string\n    const vrgb = colorString.replace(/\\s|\\)/, '').split('(')[1].split(',');\n    const colorAlpha = vrgb[3] ? vrgb[3] : null;\n    if (!colorAlpha) {\n      result = {\n        r: parseInt(vrgb[0], 10),\n        g: parseInt(vrgb[1], 10),\n        b: parseInt(vrgb[2], 10)\n      };\n    } else {\n      result = {\n        r: parseInt(vrgb[0], 10),\n        g: parseInt(vrgb[1], 10),\n        b: parseInt(vrgb[2], 10),\n        a: parseFloat(colorAlpha)\n      };\n    }\n  }\n  if (/^#/.test(colorString)) {\n    const fromHex = hexToRGB(colorString);\n    result = {\n      r: fromHex.r,\n      g: fromHex.g,\n      b: fromHex.b\n    };\n  }\n  if (/transparent|none|initial|inherit/.test(colorString)) {\n    result = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0\n    };\n  }\n  // maybe we can check for web safe colors\n  // only works in a browser\n  if (!/^#|^rgb/.test(colorString)) {\n    const siteHead = document.getElementsByTagName('head')[0];\n    siteHead.style.color = colorString;\n    let webColor = getComputedStyle(siteHead, null).color;\n    webColor = /rgb/.test(webColor) ? webColor.replace(/[^\\d,]/g, '').split(',') : [0, 0, 0];\n    siteHead.style.color = '';\n    result = {\n      r: parseInt(webColor[0], 10),\n      g: parseInt(webColor[1], 10),\n      b: parseInt(webColor[2], 10)\n    };\n  }\n  return result;\n};\n\n/**\n * Color Interpolation Function.\n *\n * @param {KUTE.colorObject} a start color\n * @param {KUTE.colorObject} b end color\n * @param {number} v progress\n * @returns {string} the resulting color\n */\nfunction colors(a, b, v) {\n  const _c = {};\n  const ep = ')';\n  const cm = ',';\n  const rgb = 'rgb(';\n  const rgba = 'rgba(';\n  Object.keys(b).forEach(c => {\n    if (c !== 'a') {\n      _c[c] = numbers(a[c], b[c], v) >> 0 || 0; // eslint-disable-line no-bitwise\n    } else if (a[c] && b[c]) {\n      _c[c] = (numbers(a[c], b[c], v) * 100 >> 0) / 100; // eslint-disable-line no-bitwise\n    }\n  });\n  return !_c.a ? rgb + _c.r + cm + _c.g + cm + _c.b + ep : rgba + _c.r + cm + _c.g + cm + _c.b + cm + _c.a + ep;\n}\n\n// Component Functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartColors(tweenProp) {\n  if (this.valuesEnd[tweenProp] && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      // eslint-disable-next-line no-param-reassign\n      elem.style[tweenProp] = colors(a, b, v);\n    };\n  }\n}\n\n// Component Properties\n// supported formats\n// 'hex', 'rgb', 'rgba' '#fff' 'rgb(0,0,0)' / 'rgba(0,0,0,0)' 'red' (IE9+)\nconst supportedColors = ['color', 'backgroundColor', 'outlineColor', 'borderColor', 'borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor'];\nconst defaultColors = {};\nsupportedColors.forEach(tweenProp => {\n  defaultColors[tweenProp] = '#000';\n});\n\n// Component Functions\nconst colorsOnStart = {};\nsupportedColors.forEach(x => {\n  colorsOnStart[x] = onStartColors;\n});\n\n/**\n * Returns the current property computed style.\n * @param {string} prop the property name\n * @returns {string} property computed style\n */\nfunction getColor(prop /* , value */) {\n  return getStyleForProperty(this.element, prop) || defaultValues[prop];\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string} value the property value\n * @returns {KUTE.colorObject} the property tween object\n */\nfunction prepareColor( /* prop, */_, value) {\n  return trueColor(value);\n}\n\n// All Component Functions\nconst colorFunctions = {\n  prepareStart: getColor,\n  prepareProperty: prepareColor,\n  onStart: colorsOnStart\n};\n\n// Component Full\nconst colorProperties = {\n  component: 'colorProperties',\n  category: 'colors',\n  properties: supportedColors,\n  defaultValues: defaultColors,\n  Interpolate: {\n    numbers,\n    colors\n  },\n  functions: colorFunctions,\n  Util: {\n    trueColor\n  }\n};\n\n// Component Special\nconst attributes = {};\nconst onStartAttr = {\n  /**\n   * onStartAttr.attr\n   *\n   * Sets the sub-property update function.\n   * @param {string} tweenProp the property name\n   */\n  attr(tweenProp) {\n    if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n      KEC[tweenProp] = (elem, vS, vE, v) => {\n        Object.keys(vE).forEach(oneAttr => {\n          KEC.attributes[oneAttr](elem, oneAttr, vS[oneAttr], vE[oneAttr], v);\n        });\n      };\n    }\n  },\n  /**\n   * onStartAttr.attributes\n   *\n   * Sets the update function for the property.\n   * @param {string} tweenProp the property name\n   */\n  attributes(tweenProp) {\n    if (!KEC[tweenProp] && this.valuesEnd.attr) {\n      KEC[tweenProp] = attributes;\n    }\n  }\n};\n\n// Component Name\nconst ComponentName = 'htmlAttributes';\n\n// Component Properties\nconst svgColors = ['fill', 'stroke', 'stop-color'];\n\n// Component Util\n/**\n * Returns non-camelcase property name.\n * @param {string} a the camelcase property name\n * @returns {string} the non-camelcase property name\n */\nfunction replaceUppercase(a) {\n  return a.replace(/[A-Z]/g, '-$&').toLowerCase();\n}\n\n// Component Functions\n/**\n * Returns the current attribute value.\n * @param {string} _ the property name\n * @param {string} value the property value\n * @returns {{[x:string]: string}} attribute value\n */\nfunction getAttr( /* tweenProp, */_, value) {\n  const attrStartValues = {};\n  Object.keys(value).forEach(attr => {\n    // get the value for 'fill-opacity' not fillOpacity\n    // also 'width' not the internal 'width_px'\n    const attribute = replaceUppercase(attr).replace(/_+[a-z]+/, '');\n    const currentValue = this.element.getAttribute(attribute);\n    attrStartValues[attribute] = svgColors.includes(attribute) ? currentValue || 'rgba(0,0,0,0)' : currentValue || (/opacity/i.test(attr) ? 1 : 0);\n  });\n  return attrStartValues;\n}\n\n/**\n * Returns the property tween object.\n * @param {string} tweenProp the property name\n * @param {string} attrObj the property value\n * @returns {number} the property tween object\n */\nfunction prepareAttr(tweenProp, attrObj) {\n  // attr (string),attrObj (object)\n  const attributesObject = {};\n  Object.keys(attrObj).forEach(p => {\n    const prop = replaceUppercase(p);\n    const regex = /(%|[a-z]+)$/;\n    const currentValue = this.element.getAttribute(prop.replace(/_+[a-z]+/, ''));\n    if (!svgColors.includes(prop)) {\n      // attributes set with unit suffixes\n      if (currentValue !== null && regex.test(currentValue)) {\n        const unit = trueDimension(currentValue).u || trueDimension(attrObj[p]).u;\n        const suffix = /%/.test(unit) ? '_percent' : `_${unit}`;\n\n        // most \"unknown\" attributes cannot register into onStart, so we manually add them\n        onStart[ComponentName][prop + suffix] = tp => {\n          if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {\n            attributes[tp] = (elem, oneAttr, a, b, v) => {\n              const _p = oneAttr.replace(suffix, '');\n              /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n              elem.setAttribute(_p, (numbers(a.v, b.v, v) * 1000 >> 0) / 1000 + b.u);\n            };\n          }\n        };\n        attributesObject[prop + suffix] = trueDimension(attrObj[p]);\n      } else if (!regex.test(attrObj[p]) || currentValue === null || currentValue && !regex.test(currentValue)) {\n        // most \"unknown\" attributes cannot register into onStart, so we manually add them\n        onStart[ComponentName][prop] = tp => {\n          if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {\n            attributes[tp] = (elem, oneAttr, a, b, v) => {\n              elem.setAttribute(oneAttr, (numbers(a, b, v) * 1000 >> 0) / 1000);\n            };\n          }\n        };\n        attributesObject[prop] = parseFloat(attrObj[p]);\n      }\n    } else {\n      // colors\n      // most \"unknown\" attributes cannot register into onStart, so we manually add them\n      onStart[ComponentName][prop] = tp => {\n        if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {\n          attributes[tp] = (elem, oneAttr, a, b, v) => {\n            elem.setAttribute(oneAttr, colors(a, b, v));\n          };\n        }\n      };\n      attributesObject[prop] = trueColor(attrObj[p]) || defaultValues.htmlAttributes[p];\n    }\n  });\n  return attributesObject;\n}\n\n// All Component Functions\nconst attrFunctions = {\n  prepareStart: getAttr,\n  prepareProperty: prepareAttr,\n  onStart: onStartAttr\n};\n\n// Component Full\nconst htmlAttributes = {\n  component: ComponentName,\n  property: 'attr',\n  // the Animation class will need some values to validate this Object attribute\n  subProperties: ['fill', 'stroke', 'stop-color', 'fill-opacity', 'stroke-opacity'],\n  defaultValue: {\n    fill: 'rgb(0,0,0)',\n    stroke: 'rgb(0,0,0)',\n    'stop-color': 'rgb(0,0,0)',\n    opacity: 1,\n    'stroke-opacity': 1,\n    'fill-opacity': 1 // same here\n  },\n  Interpolate: {\n    numbers,\n    colors\n  },\n  functions: attrFunctions,\n  // export to global for faster execution\n  Util: {\n    replaceUppercase,\n    trueColor,\n    trueDimension\n  }\n};\n\n/* opacityProperty = {\n  property: 'opacity',\n  defaultValue: 1,\n  interpolators: {numbers},\n  functions = { prepareStart, prepareProperty, onStart }\n} */\n\n// Component Functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartOpacity(tweenProp /* , value */) {\n  // opacity could be 0 sometimes, we need to check regardless\n  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      /* eslint-disable */\n      elem.style[tweenProp] = (numbers(a, b, v) * 1000 >> 0) / 1000;\n      /* eslint-enable */\n    };\n  }\n}\n\n// Component Functions\n/**\n * Returns the current property computed style.\n * @param {string} tweenProp the property name\n * @returns {string} computed style for property\n */\nfunction getOpacity(tweenProp /* , value */) {\n  return getStyleForProperty(this.element, tweenProp);\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string} value the property value\n * @returns {number} the property tween object\n */\nfunction prepareOpacity( /* tweenProp, */_, value) {\n  return parseFloat(value); // opacity always FLOAT\n}\n\n// All Component Functions\nconst opacityFunctions = {\n  prepareStart: getOpacity,\n  prepareProperty: prepareOpacity,\n  onStart: onStartOpacity\n};\n\n// Full Component\nconst OpacityProperty = {\n  component: 'opacityProperty',\n  property: 'opacity',\n  defaultValue: 1,\n  Interpolate: {\n    numbers\n  },\n  functions: opacityFunctions\n};\n\n// Component Values\nconst lowerCaseAlpha = String('abcdefghijklmnopqrstuvwxyz').split(''); // lowercase\nconst upperCaseAlpha = String('abcdefghijklmnopqrstuvwxyz').toUpperCase().split(''); // uppercase\nconst nonAlpha = String(\"~!@#$%^&*()_+{}[];'<>,./?=-\").split(''); // symbols\nconst numeric = String('0123456789').split(''); // numeric\nconst alphaNumeric = lowerCaseAlpha.concat(upperCaseAlpha, numeric); // alpha numeric\nconst allTypes = alphaNumeric.concat(nonAlpha); // all caracters\n\nconst charSet = {\n  alpha: lowerCaseAlpha,\n  // lowercase\n  upper: upperCaseAlpha,\n  // uppercase\n  symbols: nonAlpha,\n  // symbols\n  numeric,\n  alphanumeric: alphaNumeric,\n  all: allTypes\n};\n\n// Component Functions\nconst onStartWrite = {\n  /**\n   * onStartWrite.text\n   *\n   * Sets the property update function.\n   * @param {string} tweenProp the property name\n   */\n  text(tweenProp) {\n    if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n      const chars = this._textChars;\n      let charsets = charSet[defaultOptions$1.textChars];\n      if (chars in charSet) {\n        charsets = charSet[chars];\n      } else if (chars && chars.length) {\n        charsets = chars;\n      }\n      KEC[tweenProp] = (elem, a, b, v) => {\n        let initialText = '';\n        let endText = '';\n        const finalText = b === '' ? ' ' : b;\n        const firstLetterA = a.substring(0);\n        const firstLetterB = b.substring(0);\n        /* eslint-disable */\n        const pointer = charsets[Math.random() * charsets.length >> 0];\n        if (a === ' ') {\n          endText = firstLetterB.substring(Math.min(v * firstLetterB.length, firstLetterB.length) >> 0, 0);\n          elem.innerHTML = v < 1 ? endText + pointer : finalText;\n        } else if (b === ' ') {\n          initialText = firstLetterA.substring(0, Math.min((1 - v) * firstLetterA.length, firstLetterA.length) >> 0);\n          elem.innerHTML = v < 1 ? initialText + pointer : finalText;\n        } else {\n          initialText = firstLetterA.substring(firstLetterA.length, Math.min(v * firstLetterA.length, firstLetterA.length) >> 0);\n          endText = firstLetterB.substring(0, Math.min(v * firstLetterB.length, firstLetterB.length) >> 0);\n          elem.innerHTML = v < 1 ? endText + pointer + initialText : finalText;\n        }\n        /* eslint-enable */\n      };\n    }\n  },\n  /**\n   * onStartWrite.number\n   *\n   * Sets the property update function.\n   * @param {string} tweenProp the property name\n   */\n  number(tweenProp) {\n    if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n      // numbers can be 0\n      KEC[tweenProp] = (elem, a, b, v) => {\n        /* eslint-disable */\n        elem.innerHTML = numbers(a, b, v) >> 0;\n        /* eslint-enable */\n      };\n    }\n  }\n};\n\n// Component Util\n// utility for multi-child targets\n// wrapContentsSpan returns an [Element] with the SPAN.tagName and a desired class\nfunction wrapContentsSpan(el, classNAME) {\n  let textWriteWrapper;\n  let newElem;\n  if (typeof el === 'string') {\n    newElem = document.createElement('SPAN');\n    newElem.innerHTML = el;\n    newElem.className = classNAME;\n    return newElem;\n  }\n  if (!el.children.length || el.children.length && el.children[0].className !== classNAME) {\n    const elementInnerHTML = el.innerHTML;\n    textWriteWrapper = document.createElement('SPAN');\n    textWriteWrapper.className = classNAME;\n    textWriteWrapper.innerHTML = elementInnerHTML;\n    /* eslint-disable no-param-reassign -- impossible to satisfy */\n    el.appendChild(textWriteWrapper);\n    el.innerHTML = textWriteWrapper.outerHTML;\n    /* eslint-enable no-param-reassign -- impossible to satisfy */\n  } else if (el.children.length && el.children[0].className === classNAME) {\n    [textWriteWrapper] = el.children;\n  }\n  return textWriteWrapper;\n}\nfunction getTextPartsArray(el, classNAME) {\n  let elementsArray = [];\n  const len = el.children.length;\n  if (len) {\n    const textParts = [];\n    let remainingMarkup = el.innerHTML;\n    let wrapperParts;\n    for (let i = 0, currentChild, childOuter, unTaggedContent; i < len; i += 1) {\n      currentChild = el.children[i];\n      childOuter = currentChild.outerHTML;\n      wrapperParts = remainingMarkup.split(childOuter);\n      if (wrapperParts[0] !== '') {\n        unTaggedContent = wrapContentsSpan(wrapperParts[0], classNAME);\n        textParts.push(unTaggedContent);\n        remainingMarkup = remainingMarkup.replace(wrapperParts[0], '');\n      } else if (wrapperParts[1] !== '') {\n        unTaggedContent = wrapContentsSpan(wrapperParts[1].split('<')[0], classNAME);\n        textParts.push(unTaggedContent);\n        remainingMarkup = remainingMarkup.replace(wrapperParts[0].split('<')[0], '');\n      }\n      if (!currentChild.classList.contains(classNAME)) currentChild.classList.add(classNAME);\n      textParts.push(currentChild);\n      remainingMarkup = remainingMarkup.replace(childOuter, '');\n    }\n    if (remainingMarkup !== '') {\n      const unTaggedRemaining = wrapContentsSpan(remainingMarkup, classNAME);\n      textParts.push(unTaggedRemaining);\n    }\n    elementsArray = elementsArray.concat(textParts);\n  } else {\n    elementsArray = elementsArray.concat([wrapContentsSpan(el, classNAME)]);\n  }\n  return elementsArray;\n}\nfunction setSegments(target, newText) {\n  const oldTargetSegs = getTextPartsArray(target, 'text-part');\n  const newTargetSegs = getTextPartsArray(wrapContentsSpan(newText), 'text-part');\n\n  /* eslint-disable no-param-reassign */\n  target.innerHTML = '';\n  target.innerHTML += oldTargetSegs.map(s => {\n    s.className += ' oldText';\n    return s.outerHTML;\n  }).join('');\n  target.innerHTML += newTargetSegs.map(s => {\n    s.className += ' newText';\n    return s.outerHTML.replace(s.innerHTML, '');\n  }).join('');\n  /* eslint-enable no-param-reassign */\n\n  return [oldTargetSegs, newTargetSegs];\n}\nfunction createTextTweens(target, newText, ops) {\n  if (target.playing) return false;\n  const options = ops || {};\n  options.duration = 1000;\n  if (ops.duration === 'auto') {\n    options.duration = 'auto';\n  } else if (Number.isFinite(ops.duration * 1)) {\n    options.duration = ops.duration * 1;\n  }\n  const TweenContructor = connect.tween;\n  const segs = setSegments(target, newText);\n  const oldTargetSegs = segs[0];\n  const newTargetSegs = segs[1];\n  const oldTargets = [].slice.call(target.getElementsByClassName('oldText')).reverse();\n  const newTargets = [].slice.call(target.getElementsByClassName('newText'));\n  let textTween = [];\n  let totalDelay = 0;\n  textTween = textTween.concat(oldTargets.map((el, i) => {\n    options.duration = options.duration === 'auto' ? oldTargetSegs[i].innerHTML.length * 75 : options.duration;\n    options.delay = totalDelay;\n    options.onComplete = null;\n    totalDelay += options.duration;\n    return new TweenContructor(el, {\n      text: el.innerHTML\n    }, {\n      text: ''\n    }, options);\n  }));\n  textTween = textTween.concat(newTargets.map((el, i) => {\n    function onComplete() {\n      /* eslint-disable no-param-reassign */\n      target.innerHTML = newText;\n      target.playing = false;\n      /* eslint-enable no-param-reassign */\n    }\n    options.duration = options.duration === 'auto' ? newTargetSegs[i].innerHTML.length * 75 : options.duration;\n    options.delay = totalDelay;\n    options.onComplete = i === newTargetSegs.length - 1 ? onComplete : null;\n    totalDelay += options.duration;\n    return new TweenContructor(el, {\n      text: ''\n    }, {\n      text: newTargetSegs[i].innerHTML\n    }, options);\n  }));\n  textTween.start = function startTweens() {\n    if (!target.playing) {\n      textTween.forEach(tw => tw.start());\n      // eslint-disable-next-line no-param-reassign\n      target.playing = true;\n    }\n  };\n  return textTween;\n}\n\n// Component Functions\n/**\n * Returns the current element `innerHTML`.\n * @returns {string} computed style for property\n */\nfunction getWrite( /* tweenProp, value */\n) {\n  return this.element.innerHTML;\n}\n\n/**\n * Returns the property tween object.\n * @param {string} tweenProp the property name\n * @param {string} value the property value\n * @returns {number | string} the property tween object\n */\nfunction prepareText(tweenProp, value) {\n  if (tweenProp === 'number') {\n    return parseFloat(value);\n  }\n  // empty strings crash the update function\n  return value === '' ? ' ' : value;\n}\n\n// All Component Functions\nconst textWriteFunctions = {\n  prepareStart: getWrite,\n  prepareProperty: prepareText,\n  onStart: onStartWrite\n};\n\n// Full Component\nconst TextWrite = {\n  component: 'textWriteProperties',\n  category: 'textWrite',\n  properties: ['text', 'number'],\n  defaultValues: {\n    text: ' ',\n    number: '0'\n  },\n  defaultOptions: {\n    textChars: 'alpha'\n  },\n  Interpolate: {\n    numbers\n  },\n  functions: textWriteFunctions,\n  // export to global for faster execution\n  Util: {\n    charSet,\n    createTextTweens\n  }\n};\n\n/**\n * Perspective Interpolation Function.\n *\n * @param {number} a start value\n * @param {number} b end value\n * @param {string} u unit\n * @param {number} v progress\n * @returns {string} the perspective function in string format\n */\nfunction perspective(a, b, u, v) {\n  // eslint-disable-next-line no-bitwise\n  return `perspective(${((a + (b - a) * v) * 1000 >> 0) / 1000}${u})`;\n}\n\n/**\n * Translate 3D Interpolation Function.\n *\n * @param {number[]} a start [x,y,z] position\n * @param {number[]} b end [x,y,z] position\n * @param {string} u unit, usually `px` degrees\n * @param {number} v progress\n * @returns {string} the interpolated 3D translation string\n */\nfunction translate3d(a, b, u, v) {\n  const translateArray = [];\n  for (let ax = 0; ax < 3; ax += 1) {\n    translateArray[ax] = (a[ax] || b[ax]\n    // eslint-disable-next-line no-bitwise\n    ? ((a[ax] + (b[ax] - a[ax]) * v) * 1000 >> 0) / 1000 : 0) + u;\n  }\n  return `translate3d(${translateArray.join(',')})`;\n}\n\n/**\n * 3D Rotation Interpolation Function.\n *\n * @param {number} a start [x,y,z] angles\n * @param {number} b end [x,y,z] angles\n * @param {string} u unit, usually `deg` degrees\n * @param {number} v progress\n * @returns {string} the interpolated 3D rotation string\n */\nfunction rotate3d(a, b, u, v) {\n  let rotateStr = '';\n  // eslint-disable-next-line no-bitwise\n  rotateStr += a[0] || b[0] ? `rotateX(${((a[0] + (b[0] - a[0]) * v) * 1000 >> 0) / 1000}${u})` : '';\n  // eslint-disable-next-line no-bitwise\n  rotateStr += a[1] || b[1] ? `rotateY(${((a[1] + (b[1] - a[1]) * v) * 1000 >> 0) / 1000}${u})` : '';\n  // eslint-disable-next-line no-bitwise\n  rotateStr += a[2] || b[2] ? `rotateZ(${((a[2] + (b[2] - a[2]) * v) * 1000 >> 0) / 1000}${u})` : '';\n  return rotateStr;\n}\n\n/**\n * Translate 2D Interpolation Function.\n *\n * @param {number[]} a start [x,y] position\n * @param {number[]} b end [x,y] position\n * @param {string} u unit, usually `px` degrees\n * @param {number} v progress\n * @returns {string} the interpolated 2D translation string\n */\nfunction translate(a, b, u, v) {\n  const translateArray = [];\n  // eslint-disable-next-line no-bitwise\n  translateArray[0] = (a[0] === b[0] ? b[0] : ((a[0] + (b[0] - a[0]) * v) * 1000 >> 0) / 1000) + u;\n  // eslint-disable-next-line no-bitwise\n  translateArray[1] = a[1] || b[1] ? (a[1] === b[1] ? b[1] : ((a[1] + (b[1] - a[1]) * v) * 1000 >> 0) / 1000) + u : '0';\n  return `translate(${translateArray.join(',')})`;\n}\n\n/**\n * 2D Rotation Interpolation Function.\n *\n * @param {number} a start angle\n * @param {number} b end angle\n * @param {string} u unit, usually `deg` degrees\n * @param {number} v progress\n * @returns {string} the interpolated rotation\n */\nfunction rotate(a, b, u, v) {\n  // eslint-disable-next-line no-bitwise\n  return `rotate(${((a + (b - a) * v) * 1000 >> 0) / 1000}${u})`;\n}\n\n/**\n * Scale Interpolation Function.\n *\n * @param {number} a start scale\n * @param {number} b end scale\n * @param {number} v progress\n * @returns {string} the interpolated scale\n */\nfunction scale(a, b, v) {\n  // eslint-disable-next-line no-bitwise\n  return `scale(${((a + (b - a) * v) * 1000 >> 0) / 1000})`;\n}\n\n/**\n * Skew Interpolation Function.\n *\n * @param {number} a start {x,y} angles\n * @param {number} b end {x,y} angles\n * @param {string} u unit, usually `deg` degrees\n * @param {number} v progress\n * @returns {string} the interpolated string value of skew(s)\n */\nfunction skew(a, b, u, v) {\n  const skewArray = [];\n  // eslint-disable-next-line no-bitwise\n  skewArray[0] = (a[0] === b[0] ? b[0] : ((a[0] + (b[0] - a[0]) * v) * 1000 >> 0) / 1000) + u;\n  // eslint-disable-next-line no-bitwise\n  skewArray[1] = a[1] || b[1] ? (a[1] === b[1] ? b[1] : ((a[1] + (b[1] - a[1]) * v) * 1000 >> 0) / 1000) + u : '0';\n  return `skew(${skewArray.join(',')})`;\n}\n\n// Component Functions\n/**\n * Sets the property update function.\n * * same to svgTransform, htmlAttributes\n * @param {string} tweenProp the property name\n */\nfunction onStartTransform(tweenProp) {\n  if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      // eslint-disable-next-line no-param-reassign\n      elem.style[tweenProp] = (a.perspective || b.perspective ? perspective(a.perspective, b.perspective, 'px', v) : '' // one side might be 0\n      ) + (a.translate3d ? translate3d(a.translate3d, b.translate3d, 'px', v) : '') // array [x,y,z]\n      + (a.rotate3d ? rotate3d(a.rotate3d, b.rotate3d, 'deg', v) : '') // array [x,y,z]\n      + (a.skew ? skew(a.skew, b.skew, 'deg', v) : '') // array [x,y]\n      + (a.scale || b.scale ? scale(a.scale, b.scale, v) : ''); // one side might be 0\n    };\n  }\n}\n\n// same to svg transform, attr\n// the component developed for modern browsers supporting non-prefixed transform\n\n// Component Functions\n/**\n * Returns the current property inline style.\n * @param {string} tweenProp the property name\n * @returns {string} inline style for property\n */\nfunction getTransform(tweenProp /* , value */) {\n  const currentStyle = getInlineStyle(this.element);\n  return currentStyle[tweenProp] ? currentStyle[tweenProp] : defaultValues[tweenProp];\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {Object<string, string | number | (string | number)[]>} obj the property value\n * @returns {KUTE.transformFObject} the property tween object\n */\nfunction prepareTransform( /* prop, */_, obj) {\n  const prepAxis = ['X', 'Y', 'Z']; // coordinates\n  const transformObject = {};\n  const translateArray = [];\n  const rotateArray = [];\n  const skewArray = [];\n  const arrayFunctions = ['translate3d', 'translate', 'rotate3d', 'skew'];\n  Object.keys(obj).forEach(x => {\n    const pv = typeof obj[x] === 'object' && obj[x].length ? obj[x].map(v => parseInt(v, 10)) : parseInt(obj[x], 10);\n    if (arrayFunctions.includes(x)) {\n      const propId = x === 'translate' || x === 'rotate' ? `${x}3d` : x;\n      if (x === 'skew') {\n        transformObject[propId] = pv.length ? [pv[0] || 0, pv[1] || 0] : [pv || 0, 0];\n      } else if (x === 'translate') {\n        transformObject[propId] = pv.length ? [pv[0] || 0, pv[1] || 0, pv[2] || 0] : [pv || 0, 0, 0];\n      } else {\n        // translate3d | rotate3d\n        transformObject[propId] = [pv[0] || 0, pv[1] || 0, pv[2] || 0];\n      }\n    } else if (/[XYZ]/.test(x)) {\n      const fn = x.replace(/[XYZ]/, '');\n      const fnId = fn === 'skew' ? fn : `${fn}3d`;\n      const fnLen = fn === 'skew' ? 2 : 3;\n      let fnArray = [];\n      if (fn === 'translate') {\n        fnArray = translateArray;\n      } else if (fn === 'rotate') {\n        fnArray = rotateArray;\n      } else if (fn === 'skew') {\n        fnArray = skewArray;\n      }\n      for (let fnIndex = 0; fnIndex < fnLen; fnIndex += 1) {\n        const fnAxis = prepAxis[fnIndex];\n        fnArray[fnIndex] = `${fn}${fnAxis}` in obj ? parseInt(obj[`${fn}${fnAxis}`], 10) : 0;\n      }\n      transformObject[fnId] = fnArray;\n    } else if (x === 'rotate') {\n      //  rotate\n      transformObject.rotate3d = [0, 0, pv];\n    } else {\n      // scale | perspective\n      transformObject[x] = x === 'scale' ? parseFloat(obj[x]) : pv;\n    }\n  });\n  return transformObject;\n}\n\n/**\n * Prepare tween object in advance for `to()` method.\n * @param {string} tweenProp the property name\n */\nfunction crossCheckTransform(tweenProp) {\n  if (this.valuesEnd[tweenProp]) {\n    if (this.valuesEnd[tweenProp]) {\n      if (this.valuesEnd[tweenProp].perspective && !this.valuesStart[tweenProp].perspective) {\n        this.valuesStart[tweenProp].perspective = this.valuesEnd[tweenProp].perspective;\n      }\n    }\n  }\n}\n\n// All Component Functions\nconst transformFunctions = {\n  prepareStart: getTransform,\n  prepareProperty: prepareTransform,\n  onStart: onStartTransform,\n  crossCheck: crossCheckTransform\n};\nconst supportedTransformProperties = ['perspective', 'translate3d', 'translateX', 'translateY', 'translateZ', 'translate', 'rotate3d', 'rotateX', 'rotateY', 'rotateZ', 'rotate', 'skewX', 'skewY', 'skew', 'scale'];\nconst defaultTransformValues = {\n  perspective: 400,\n  translate3d: [0, 0, 0],\n  translateX: 0,\n  translateY: 0,\n  translateZ: 0,\n  translate: [0, 0],\n  rotate3d: [0, 0, 0],\n  rotateX: 0,\n  rotateY: 0,\n  rotateZ: 0,\n  rotate: 0,\n  skewX: 0,\n  skewY: 0,\n  skew: [0, 0],\n  scale: 1\n};\n\n// Full Component\nconst TransformFunctions = {\n  component: 'transformFunctions',\n  property: 'transform',\n  subProperties: supportedTransformProperties,\n  defaultValues: defaultTransformValues,\n  functions: transformFunctions,\n  Interpolate: {\n    perspective,\n    translate3d,\n    rotate3d,\n    translate,\n    rotate,\n    scale,\n    skew\n  }\n};\n\n// Component Functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartDraw(tweenProp) {\n  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      /* eslint-disable no-bitwise -- impossible to satisfy */\n      const pathLength = (a.l * 100 >> 0) / 100;\n      const start = (numbers(a.s, b.s, v) * 100 >> 0) / 100;\n      const end = (numbers(a.e, b.e, v) * 100 >> 0) / 100;\n      const offset = 0 - start;\n      const dashOne = end + offset;\n      // eslint-disable-next-line no-param-reassign -- impossible to satisfy\n      elem.style.strokeDashoffset = `${offset}px`;\n      // eslint-disable-next-line no-param-reassign -- impossible to satisfy\n      elem.style.strokeDasharray = `${((dashOne < 1 ? 0 : dashOne) * 100 >> 0) / 100}px, ${pathLength}px`;\n      /* eslint-disable no-bitwise -- impossible to satisfy */\n    };\n  }\n}\n\n// Component Util\n/**\n * Convert a `<path>` length percent value to absolute.\n * @param {string} v raw value\n * @param {number} l length value\n * @returns {number} the absolute value\n */\nfunction percent(v, l) {\n  return parseFloat(v) / 100 * l;\n}\n\n/**\n * Returns the `<rect>` length.\n * It doesn't compute `rx` and / or `ry` of the element.\n * @see http://stackoverflow.com/a/30376660\n * @param {SVGRectElement} el target element\n * @returns {number} the `<rect>` length\n */\nfunction getRectLength(el) {\n  const w = el.getAttribute('width');\n  const h = el.getAttribute('height');\n  return w * 2 + h * 2;\n}\n\n/**\n * Returns the `<polyline>` / `<polygon>` length.\n * @param {SVGPolylineElement | SVGPolygonElement} el target element\n * @returns {number} the element length\n */\nfunction getPolyLength(el) {\n  const points = el.getAttribute('points').split(' ');\n  let len = 0;\n  if (points.length > 1) {\n    const coord = p => {\n      const c = p.split(',');\n      if (c.length !== 2) {\n        return 0;\n      } // return undefined\n      if (Number.isNaN(c[0] * 1) || Number.isNaN(c[1] * 1)) {\n        return 0;\n      }\n      return [parseFloat(c[0]), parseFloat(c[1])];\n    };\n    const dist = (c1, c2) => {\n      if (c1 !== undefined && c2 !== undefined) {\n        return Math.sqrt((c2[0] - c1[0]) ** 2 + (c2[1] - c1[1]) ** 2);\n      }\n      return 0;\n    };\n    if (points.length > 2) {\n      for (let i = 0; i < points.length - 1; i += 1) {\n        len += dist(coord(points[i]), coord(points[i + 1]));\n      }\n    }\n    len += el.tagName === 'polygon' ? dist(coord(points[0]), coord(points[points.length - 1])) : 0;\n  }\n  return len;\n}\n\n/**\n * Returns the `<line>` length.\n * @param {SVGLineElement} el target element\n * @returns {number} the element length\n */\nfunction getLineLength(el) {\n  const x1 = el.getAttribute('x1');\n  const x2 = el.getAttribute('x2');\n  const y1 = el.getAttribute('y1');\n  const y2 = el.getAttribute('y2');\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n}\n\n/**\n * Returns the `<circle>` length.\n * @param {SVGCircleElement} el target element\n * @returns {number} the element length\n */\nfunction getCircleLength(el) {\n  const r = el.getAttribute('r');\n  return 2 * Math.PI * r;\n}\n\n// returns the length of an ellipse\n/**\n * Returns the `<ellipse>` length.\n * @param {SVGEllipseElement} el target element\n * @returns {number} the element length\n */\nfunction getEllipseLength(el) {\n  const rx = el.getAttribute('rx');\n  const ry = el.getAttribute('ry');\n  const len = 2 * rx;\n  const wid = 2 * ry;\n  return Math.sqrt(0.5 * (len * len + wid * wid)) * (Math.PI * 2) / 2;\n}\n\n/**\n * Returns the shape length.\n * @param {SVGPathCommander.shapeTypes} el target element\n * @returns {number} the element length\n */\nfunction getTotalLength$1(el) {\n  if (el.tagName === 'rect') {\n    return getRectLength(el);\n  }\n  if (el.tagName === 'circle') {\n    return getCircleLength(el);\n  }\n  if (el.tagName === 'ellipse') {\n    return getEllipseLength(el);\n  }\n  if (['polygon', 'polyline'].includes(el.tagName)) {\n    return getPolyLength(el);\n  }\n  if (el.tagName === 'line') {\n    return getLineLength(el);\n  }\n  // ESLint\n  return 0;\n}\n\n/**\n * Returns the property tween object.\n * @param {SVGPathCommander.shapeTypes} element the target element\n * @param {string | KUTE.drawObject} value the property value\n * @returns {KUTE.drawObject} the property tween object\n */\nfunction getDraw(element, value) {\n  const length = /path|glyph/.test(element.tagName) ? element.getTotalLength() : getTotalLength$1(element);\n  let start;\n  let end;\n  let dasharray;\n  let offset;\n  if (value instanceof Object && Object.keys(value).every(v => ['s', 'e', 'l'].includes(v))) {\n    return value;\n  }\n  if (typeof value === 'string') {\n    const v = value.split(/,|\\s/);\n    start = /%/.test(v[0]) ? percent(v[0].trim(), length) : parseFloat(v[0]);\n    end = /%/.test(v[1]) ? percent(v[1].trim(), length) : parseFloat(v[1]);\n  } else if (typeof value === 'undefined') {\n    offset = parseFloat(getStyleForProperty(element, 'stroke-dashoffset'));\n    dasharray = getStyleForProperty(element, 'stroke-dasharray').split(',');\n    start = 0 - offset;\n    end = parseFloat(dasharray[0]) + start || length;\n  }\n  return {\n    s: start,\n    e: end,\n    l: length\n  };\n}\n\n/**\n * Reset CSS properties associated with the `draw` property.\n * @param {SVGPathCommander.shapeTypes} element target\n */\nfunction resetDraw(elem) {\n  /* eslint-disable no-param-reassign -- impossible to satisfy */\n  elem.style.strokeDashoffset = '';\n  elem.style.strokeDasharray = '';\n  /* eslint-disable no-param-reassign -- impossible to satisfy */\n}\n\n// Component Functions\n/**\n * Returns the property tween object.\n * @returns {KUTE.drawObject} the property tween object\n */\nfunction getDrawValue( /* prop, value */\n) {\n  return getDraw(this.element);\n}\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string | KUTE.drawObject} value the property value\n * @returns {KUTE.drawObject} the property tween object\n */\nfunction prepareDraw(_, value) {\n  return getDraw(this.element, value);\n}\n\n// All Component Functions\nconst svgDrawFunctions = {\n  prepareStart: getDrawValue,\n  prepareProperty: prepareDraw,\n  onStart: onStartDraw\n};\n\n// Component Full\nconst SvgDrawProperty = {\n  component: 'svgDraw',\n  property: 'draw',\n  defaultValue: '0% 0%',\n  Interpolate: {\n    numbers\n  },\n  functions: svgDrawFunctions,\n  // Export to global for faster execution\n  Util: {\n    getRectLength,\n    getPolyLength,\n    getLineLength,\n    getCircleLength,\n    getEllipseLength,\n    getTotalLength: getTotalLength$1,\n    resetDraw,\n    getDraw,\n    percent\n  }\n};\n\n/**\n * Splits an extended A (arc-to) segment into two cubic-bezier segments.\n *\n * @param {SVGPath.pathArray} path the `pathArray` this segment belongs to\n * @param {string[]} allPathCommands all previous path commands\n * @param {number} i the segment index\n */\n\nfunction fixArc(path, allPathCommands, i) {\n  if (path[i].length > 7) {\n    path[i].shift();\n    const segment = path[i];\n    let ni = i; // ESLint\n    while (segment.length) {\n      // if created multiple C:s, their original seg is saved\n      allPathCommands[i] = 'A';\n      path.splice(ni += 1, 0, ['C', ...segment.splice(0, 6)]);\n    }\n    path.splice(i, 1);\n  }\n}\n\n/**\n * Segment params length\n * @type {Record<string, number>}\n */\nconst paramsCount = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  r: 4,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0\n};\n\n/**\n * Iterates an array to check if it's an actual `pathArray`.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nfunction isPathArray(path) {\n  return Array.isArray(path) && path.every(seg => {\n    const lk = seg[0].toLowerCase();\n    return paramsCount[lk] === seg.length - 1 && 'achlmqstvz'.includes(lk);\n  });\n}\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nfunction isAbsoluteArray(path) {\n  return isPathArray(path)\n  // `isPathArray` also checks if it's `Array`\n  && path.every(([x]) => x === x.toUpperCase());\n}\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all segments are in non-shorthand notation\n * with absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nfunction isNormalizedArray(path) {\n  // `isAbsoluteArray` also checks if it's `Array`\n  return isAbsoluteArray(path) && path.every(([pc]) => 'ACLMQZ'.includes(pc));\n}\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all C (cubic bezier) segments.\n *\n * @param {string | SVGPath.pathArray} path the `Array` to be checked\n * @returns {boolean} iteration result\n */\nfunction isCurveArray(path) {\n  // `isPathArray` also checks if it's `Array`\n  return isNormalizedArray(path) && path.every(([pc]) => 'MC'.includes(pc));\n}\n\n/**\n * Returns a clone of an existing `pathArray`.\n *\n * @param {SVGPath.pathArray | SVGPath.pathSegment} path the source `pathArray`\n * @returns {any} the cloned `pathArray`\n */\nfunction clonePath(path) {\n  return path.map(x => Array.isArray(x) ? [...x] : x);\n}\n\n/**\n * Breaks the parsing of a pathString once a segment is finalized.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction finalizeSegment(path) {\n  let pathCommand = path.pathValue[path.segmentStart];\n  let LK = pathCommand.toLowerCase();\n  const {\n    data\n  } = path;\n  while (data.length >= paramsCount[LK]) {\n    // overloaded `moveTo`\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\n    if (LK === 'm' && data.length > 2) {\n      path.segments.push([pathCommand, ...data.splice(0, 2)]);\n      LK = 'l';\n      pathCommand = pathCommand === 'm' ? 'l' : 'L';\n    } else {\n      path.segments.push([pathCommand, ...data.splice(0, paramsCount[LK])]);\n    }\n    if (!paramsCount[LK]) {\n      break;\n    }\n  }\n}\nconst error = 'SVGPathCommander error';\n\n/**\n * Validates an A (arc-to) specific path command value.\n * Usually a `large-arc-flag` or `sweep-flag`.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction scanFlag(path) {\n  const {\n    index,\n    pathValue\n  } = path;\n  const code = pathValue.charCodeAt(index);\n  if (code === 0x30 /* 0 */) {\n    path.param = 0;\n    path.index += 1;\n    return;\n  }\n  if (code === 0x31 /* 1 */) {\n    path.param = 1;\n    path.index += 1;\n    return;\n  }\n  path.err = `${error}: invalid Arc flag \"${pathValue[index]}\", expecting 0 or 1 at index ${index}`;\n}\n\n/**\n * Checks if a character is a digit.\n *\n * @param {number} code the character to check\n * @returns {boolean} check result\n */\nfunction isDigit(code) {\n  return code >= 48 && code <= 57; // 0..9\n}\nconst invalidPathValue = 'Invalid path value';\n\n/**\n * Validates every character of the path string,\n * every path command, negative numbers or floating point numbers.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction scanParam(path) {\n  const {\n    max,\n    pathValue,\n    index: start\n  } = path;\n  let index = start;\n  let zeroFirst = false;\n  let hasCeiling = false;\n  let hasDecimal = false;\n  let hasDot = false;\n  let ch;\n  if (index >= max) {\n    // path.err = 'SvgPath: missed param (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\n    return;\n  }\n  ch = pathValue.charCodeAt(index);\n  if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {\n    index += 1;\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\n    ch = pathValue.charCodeAt(index);\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  if (!isDigit(ch) && ch !== 0x2E /* . */) {\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" is not a number`;\n    return;\n  }\n  if (ch !== 0x2E /* . */) {\n    zeroFirst = ch === 0x30 /* 0 */;\n    index += 1;\n    ch = pathValue.charCodeAt(index);\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\n        // are illegal (at pos ' + start + ')';\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${pathValue[start]}\" illegal number`;\n        return;\n      }\n    }\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasCeiling = true;\n    }\n    ch = pathValue.charCodeAt(index);\n  }\n  if (ch === 0x2E /* . */) {\n    hasDot = true;\n    index += 1;\n    while (isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasDecimal = true;\n    }\n    ch = pathValue.charCodeAt(index);\n  }\n  if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid float exponent`;\n      return;\n    }\n    index += 1;\n    ch = pathValue.charCodeAt(index);\n    if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {\n      index += 1;\n    }\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\n        index += 1;\n      }\n    } else {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid integer exponent`;\n      return;\n    }\n  }\n  path.index = index;\n  path.param = +path.pathValue.slice(start, index);\n}\n\n/**\n * Checks if the character is a space.\n *\n * @param {number} ch the character to check\n * @returns {boolean} check result\n */\nfunction isSpace(ch) {\n  const specialSpaces = [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];\n  /* istanbul ignore next */\n  return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029 // Line terminators\n  // White spaces\n  || ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && specialSpaces.includes(ch);\n}\n\n/**\n * Points the parser to the next character in the\n * path string every time it encounters any kind of\n * space character.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction skipSpaces(path) {\n  const {\n    pathValue,\n    max\n  } = path;\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\n    path.index += 1;\n  }\n}\n\n/**\n * Checks if the character is a path command.\n *\n * @param {any} code the character to check\n * @returns {boolean} check result\n */\nfunction isPathCommand(code) {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6D /* m */:\n    case 0x7A /* z */:\n    case 0x6C /* l */:\n    case 0x68 /* h */:\n    case 0x76 /* v */:\n    case 0x63 /* c */:\n    case 0x73 /* s */:\n    case 0x71 /* q */:\n    case 0x74 /* t */:\n    case 0x61 /* a */:\n      // case 0x72/* r */:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Checks if the character is or belongs to a number.\n * [0-9]|+|-|.\n *\n * @param {number} code the character to check\n * @returns {boolean} check result\n */\nfunction isDigitStart(code) {\n  return code >= 48 && code <= 57 /* 0..9 */ || code === 0x2B /* + */ || code === 0x2D /* - */ || code === 0x2E; /* . */\n}\n\n/**\n * Checks if the character is an A (arc-to) path command.\n *\n * @param {number} code the character to check\n * @returns {boolean} check result\n */\nfunction isArcCommand(code) {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  return (code | 0x20) === 0x61;\n}\n\n/**\n * Scans every character in the path string to determine\n * where a segment starts and where it ends.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction scanSegment(path) {\n  const {\n    max,\n    pathValue,\n    index\n  } = path;\n  const cmdCode = pathValue.charCodeAt(index);\n  const reqParams = paramsCount[pathValue[index].toLowerCase()];\n  path.segmentStart = index;\n  if (!isPathCommand(cmdCode)) {\n    path.err = `${error}: ${invalidPathValue} \"${pathValue[index]}\" is not a path command`;\n    return;\n  }\n  path.index += 1;\n  skipSpaces(path);\n  path.data = [];\n  if (!reqParams) {\n    // Z\n    finalizeSegment(path);\n    return;\n  }\n  for (;;) {\n    for (let i = reqParams; i > 0; i -= 1) {\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);else scanParam(path);\n      if (path.err.length) {\n        return;\n      }\n      path.data.push(path.param);\n      skipSpaces(path);\n\n      // after ',' param is mandatory\n      if (path.index < max && pathValue.charCodeAt(path.index) === 0x2C /* , */) {\n        path.index += 1;\n        skipSpaces(path);\n      }\n    }\n    if (path.index >= path.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\n      break;\n    }\n  }\n  finalizeSegment(path);\n}\n\n/**\n * The `PathParser` is used by the `parsePathString` static method\n * to generate a `pathArray`.\n *\n * @param {string} pathString\n */\nfunction PathParser(pathString) {\n  /** @type {SVGPath.pathArray} */\n  this.segments = [];\n  /** @type {string} */\n  this.pathValue = pathString;\n  /** @type {number} */\n  this.max = pathString.length;\n  /** @type {number} */\n  this.index = 0;\n  /** @type {number} */\n  this.param = 0.0;\n  /** @type {number} */\n  this.segmentStart = 0;\n  /** @type {any} */\n  this.data = [];\n  /** @type {string} */\n  this.err = '';\n}\n\n/**\n * Parses a path string value and returns an array\n * of segments we like to call `pathArray`.\n *\n * @param {SVGPath.pathArray | string} pathInput the string to be parsed\n * @returns {SVGPath.pathArray | string} the resulted `pathArray` or error string\n */\nfunction parsePathString(pathInput) {\n  if (isPathArray(pathInput)) {\n    return clonePath(pathInput);\n  }\n  const path = new PathParser(pathInput);\n  skipSpaces(path);\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n  return path.err ? path.err : path.segments;\n}\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to absolute values.\n *\n * @param {string | SVGPath.pathArray} pathInput the path string | object\n * @returns {SVGPath.absoluteArray} the resulted `pathArray` with absolute values\n */\nfunction pathToAbsolute(pathInput) {\n  /* istanbul ignore else */\n  if (isAbsoluteArray(pathInput)) {\n    // `isAbsoluteArray` checks if it's `pathArray`\n    return clonePath(pathInput);\n  }\n  const path = parsePathString(pathInput);\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n\n  // the `absoluteSegment[]` is for sure an `absolutePath`\n  return path.map(segment => {\n    const values = segment.slice(1).map(Number);\n    const [pathCommand] = segment;\n    /** @type {SVGPath.absoluteCommand} */\n    const absCommand = pathCommand.toUpperCase();\n    if (pathCommand === 'M') {\n      [x, y] = values;\n      mx = x;\n      my = y;\n      return ['M', x, y];\n    }\n    /** @type {SVGPath.absoluteSegment} */\n    let absoluteSegment = [];\n    if (pathCommand !== absCommand) {\n      switch (absCommand) {\n        case 'A':\n          absoluteSegment = [absCommand, values[0], values[1], values[2], values[3], values[4], values[5] + x, values[6] + y];\n          break;\n        case 'V':\n          absoluteSegment = [absCommand, values[0] + y];\n          break;\n        case 'H':\n          absoluteSegment = [absCommand, values[0] + x];\n          break;\n        default:\n          {\n            // use brakets for `eslint: no-case-declaration`\n            // https://stackoverflow.com/a/50753272/803358\n            const absValues = values.map((n, j) => n + (j % 2 ? y : x));\n            // for n, l, c, s, q, t\n            absoluteSegment = [absCommand, ...absValues];\n          }\n      }\n    } else {\n      absoluteSegment = [absCommand, ...values];\n    }\n    const segLength = absoluteSegment.length;\n    switch (absCommand) {\n      case 'Z':\n        x = mx;\n        y = my;\n        break;\n      case 'H':\n        [, x] = absoluteSegment;\n        break;\n      case 'V':\n        [, y] = absoluteSegment;\n        break;\n      default:\n        x = absoluteSegment[segLength - 2];\n        y = absoluteSegment[segLength - 1];\n        if (absCommand === 'M') {\n          mx = x;\n          my = y;\n        }\n    }\n    return absoluteSegment;\n  });\n}\n\n/**\n * Normalizes a single segment of a `pathArray` object.\n *\n * @param {SVGPath.pathSegment} segment the segment object\n * @param {any} params the coordinates of the previous segment\n * @returns {SVGPath.normalSegment} the normalized segment\n */\nfunction normalizeSegment(segment, params) {\n  const [pathCommand] = segment;\n  const {\n    x1: px1,\n    y1: py1,\n    x2: px2,\n    y2: py2\n  } = params;\n  const values = segment.slice(1).map(Number);\n  let result = segment;\n  if (!'TQ'.includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n  if (pathCommand === 'H') {\n    result = ['L', segment[1], py1];\n  } else if (pathCommand === 'V') {\n    result = ['L', px1, segment[1]];\n  } else if (pathCommand === 'S') {\n    const x1 = px1 * 2 - px2;\n    const y1 = py1 * 2 - py2;\n    params.x1 = x1;\n    params.y1 = y1;\n    result = ['C', x1, y1, ...values];\n  } else if (pathCommand === 'T') {\n    const qx = px1 * 2 - params.qx;\n    const qy = py1 * 2 - params.qy;\n    params.qx = qx;\n    params.qy = qy;\n    result = ['Q', qx, qy, ...values];\n  } else if (pathCommand === 'Q') {\n    const [nqx, nqy] = values;\n    params.qx = nqx;\n    params.qy = nqy;\n  }\n  return result;\n}\n\n/**\n * @type {SVGPath.parserParams}\n */\nconst paramsParser = {\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n  x: 0,\n  y: 0,\n  qx: null,\n  qy: null\n};\n\n/**\n * Normalizes a `path` object for further processing:\n * * convert segments to absolute values\n * * convert shorthand path commands to their non-shorthand notation\n *\n * @param {string | SVGPath.pathArray} pathInput the string to be parsed or 'pathArray'\n * @returns {SVGPath.normalArray} the normalized `pathArray`\n */\nfunction normalizePath(pathInput) {\n  if (isNormalizedArray(pathInput)) {\n    return clonePath(pathInput);\n  }\n\n  /** @type {SVGPath.normalArray} */\n  const path = pathToAbsolute(pathInput);\n  const params = {\n    ...paramsParser\n  };\n  const ii = path.length;\n  for (let i = 0; i < ii; i += 1) {\n    path[i];\n    path[i] = normalizeSegment(path[i], params);\n    const segment = path[i];\n    const seglen = segment.length;\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n  }\n  return path;\n}\n\n/**\n * Returns an {x,y} vector rotated by a given\n * angle in radian.\n *\n * @param {number} x the initial vector x\n * @param {number} y the initial vector y\n * @param {number} rad the radian vector angle\n * @returns {{x: number, y: number}} the rotated vector\n */\nfunction rotateVector(x, y, rad) {\n  const X = x * Math.cos(rad) - y * Math.sin(rad);\n  const Y = x * Math.sin(rad) + y * Math.cos(rad);\n  return {\n    x: X,\n    y: Y\n  };\n}\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n *\n * @param {number} X1 the starting x position\n * @param {number} Y1 the starting y position\n * @param {number} RX x-radius of the arc\n * @param {number} RY y-radius of the arc\n * @param {number} angle x-axis-rotation of the arc\n * @param {number} LAF large-arc-flag of the arc\n * @param {number} SF sweep-flag of the arc\n * @param {number} X2 the ending x position\n * @param {number} Y2 the ending y position\n * @param {number[]=} recursive the parameters needed to split arc into 2 segments\n * @return {number[]} the resulting cubic-bezier segment(s)\n */\nfunction arcToCubic(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, recursive) {\n  let x1 = X1;\n  let y1 = Y1;\n  let rx = RX;\n  let ry = RY;\n  let x2 = X2;\n  let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = Math.PI * 120 / 180;\n  const rad = Math.PI / 180 * (+angle || 0);\n  /** @type {number[]} */\n  let res = [];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = x * x / (rx * rx) + y * y / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n    const k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n    cx = k * rx * y / ry + (x1 + x2) / 2;\n    cy = k * -ry * x / rx + (y1 + y2) / 2;\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin(((y1 - cy) / ry * 10 ** 9 >> 0) / 10 ** 9);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin(((y2 - cy) / ry * 10 ** 9 >> 0) / 10 ** 9);\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = 4 / 3 * rx * t;\n  const hy = 4 / 3 * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [...m2, ...m3, ...m4, ...res];\n  }\n  res = [...m2, ...m3, ...m4, ...res];\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n}\n\n/**\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\n *\n * @param {number} x1 curve start x\n * @param {number} y1 curve start y\n * @param {number} qx control point x\n * @param {number} qy control point y\n * @param {number} x2 curve end x\n * @param {number} y2 curve end y\n * @returns {number[]} the cubic-bezier segment\n */\nfunction quadToCubic(x1, y1, qx, qy, x2, y2) {\n  const r13 = 1 / 3;\n  const r23 = 2 / 3;\n  return [r13 * x1 + r23 * qx,\n  // cpx1\n  r13 * y1 + r23 * qy,\n  // cpy1\n  r13 * x2 + r23 * qx,\n  // cpx2\n  r13 * y2 + r23 * qy,\n  // cpy2\n  x2, y2 // x,y\n  ];\n}\n\n/**\n * Returns the coordinates of a specified distance\n * ratio between two points.\n *\n * @param {[number, number]} a the first point coordinates\n * @param {[number, number]} b the second point coordinates\n * @param {number} t the ratio\n * @returns {[number, number]} the midpoint coordinates\n */\nfunction midPoint(a, b, t) {\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\n}\n\n/**\n * Returns the square root of the distance\n * between two given points.\n *\n * @param {[number, number]} a the first point coordinates\n * @param {[number, number]} b the second point coordinates\n * @returns {number} the distance value\n */\nfunction distanceSquareRoot(a, b) {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a line (L,V,H,Z) segment.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number=} distance the distance to point\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentLineFactory(x1, y1, x2, y2, distance) {\n  const length = distanceSquareRoot([x1, y1], [x2, y2]);\n  let point = {\n    x: 0,\n    y: 0\n  };\n\n  /* istanbul ignore else */\n  if (typeof distance === 'number') {\n    if (distance <= 0) {\n      point = {\n        x: x1,\n        y: y1\n      };\n    } else if (distance >= length) {\n      point = {\n        x: x2,\n        y: y2\n      };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\n      point = {\n        x,\n        y\n      };\n    }\n  }\n  return {\n    length,\n    point,\n    min: {\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2)\n    },\n    max: {\n      x: Math.max(x1, x2),\n      y: Math.max(y1, y2)\n    }\n  };\n}\n\n/**\n * Converts an L (line-to) segment to C (cubic-bezier).\n *\n * @param {number} x1 line start x\n * @param {number} y1 line start y\n * @param {number} x2 line end x\n * @param {number} y2 line end y\n * @returns {number[]} the cubic-bezier segment\n */\nfunction lineToCubic(x1, y1, x2, y2) {\n  const t = 0.5;\n  /** @type {[number, number]} */\n  const p0 = [x1, y1];\n  /** @type {[number, number]} */\n  const p1 = [x2, y2];\n  const p2 = midPoint(p0, p1, t);\n  const p3 = midPoint(p1, p2, t);\n  const p4 = midPoint(p2, p3, t);\n  const p5 = midPoint(p3, p4, t);\n  const p6 = midPoint(p4, p5, t);\n  const seg1 = [...p0, ...p2, ...p4, ...p6, t];\n  const cp1 = segmentLineFactory(...seg1).point;\n  const seg2 = [...p6, ...p5, ...p3, ...p1, 0];\n  const cp2 = segmentLineFactory(...seg2).point;\n  return [cp1.x, cp1.y, cp2.x, cp2.y, x2, y2];\n}\n\n/**\n * Converts any segment to C (cubic-bezier).\n *\n * @param {SVGPath.pathSegment} segment the source segment\n * @param {SVGPath.parserParams} params the source segment parameters\n * @returns {SVGPath.cubicSegment | SVGPath.MSegment} the cubic-bezier segment\n */\nfunction segmentToCubic(segment, params) {\n  const [pathCommand] = segment;\n  const values = segment.slice(1).map(Number);\n  const [x, y] = values;\n  let args;\n  const {\n    x1: px1,\n    y1: py1,\n    x: px,\n    y: py\n  } = params;\n  if (!'TQ'.includes(pathCommand)) {\n    params.qx = null;\n    params.qy = null;\n  }\n  switch (pathCommand) {\n    case 'M':\n      params.x = x;\n      params.y = y;\n      return segment;\n    case 'A':\n      args = [px1, py1, ...values];\n      return ['C', ...arcToCubic(...args)];\n    case 'Q':\n      params.qx = x;\n      params.qy = y;\n      args = [px1, py1, ...values];\n      return ['C', ...quadToCubic(...args)];\n    case 'L':\n      return ['C', ...lineToCubic(px1, py1, x, y)];\n    case 'Z':\n      return ['C', ...lineToCubic(px1, py1, px, py)];\n  }\n  return segment;\n}\n\n/**\n * Parses a path string value or 'pathArray' and returns a new one\n * in which all segments are converted to cubic-bezier.\n *\n * In addition, un-necessary `Z` segment is removed if previous segment\n * extends to the `M` segment.\n *\n * @param {string | SVGPath.pathArray} pathInput the string to be parsed or 'pathArray'\n * @returns {SVGPath.curveArray} the resulted `pathArray` converted to cubic-bezier\n */\nfunction pathToCurve(pathInput) {\n  /* istanbul ignore else */\n  if (isCurveArray(pathInput)) {\n    // `isCurveArray` checks if it's `pathArray`\n    return clonePath(pathInput);\n  }\n\n  // const path = fixPath(normalizePath(pathInput));\n  const path = normalizePath(pathInput);\n  const params = {\n    ...paramsParser\n  };\n  const allPathCommands = [];\n  let pathCommand = ''; // ts-lint\n  let ii = path.length;\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n    allPathCommands[i] = pathCommand;\n    path[i] = segmentToCubic(path[i], params);\n    fixArc(path, allPathCommands, i);\n    ii = path.length;\n    const segment = path[i];\n    const seglen = segment.length;\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n  }\n  return path;\n}\n\n/**\n * SVGPathCommander default options\n * @type {SVGPath.options}\n */\nconst defaultOptions = {\n  origin: [0, 0, 0],\n  round: 4\n};\n\n/**\n * Rounds the values of a `pathArray` instance to\n * a specified amount of decimals and returns it.\n *\n * @param {SVGPath.pathArray} path the source `pathArray`\n * @param {number | 'off'} roundOption the amount of decimals to round numbers to\n * @returns {SVGPath.pathArray} the resulted `pathArray` with rounded values\n */\nfunction roundPath(path, roundOption) {\n  let {\n    round\n  } = defaultOptions;\n  if (roundOption === 'off' || round === 'off') return clonePath(path);\n  // round = roundOption >= 1 ? roundOption : round;\n  // allow for ZERO decimals\n  round = roundOption >= 0 ? roundOption : round;\n  // to round values to the power\n  // the `round` value must be integer\n  const pow = typeof round === 'number' && round >= 1 ? 10 ** round : 1;\n  return path.map(pi => {\n    const values = pi.slice(1).map(Number).map(n => round ? Math.round(n * pow) / pow : Math.round(n));\n    return [pi[0], ...values];\n  });\n}\n\n/**\n * Returns a valid `d` attribute string value created\n * by rounding values and concatenating the `pathArray` segments.\n *\n * @param {SVGPath.pathArray} path the `pathArray` object\n * @param {number | 'off'} round amount of decimals to round values to\n * @returns {string} the concatenated path string\n */\nfunction pathToString(path, round) {\n  return roundPath(path, round).map(x => x[0] + x.slice(1).join(' ')).join('');\n}\n\n/**\n * Split a path into an `Array` of sub-path strings.\n *\n * In the process, values are converted to absolute\n * for visual consistency.\n *\n * @param {SVGPath.pathArray} pathInput the source `pathArray`\n * @return {SVGPath.pathArray[]} an array with all sub-path strings\n */\nfunction splitPath(pathInput) {\n  /** @type {SVGPath.pathArray[]} */\n  const composite = [];\n  /** @type {SVGPath.pathArray} */\n  let path;\n  let pi = -1;\n  pathInput.forEach(seg => {\n    if (seg[0] === 'M') {\n      path = [seg];\n      pi += 1;\n    } else {\n      path = [...path, seg];\n    }\n    composite[pi] = path;\n  });\n  return composite;\n}\n\n/**\n *\n * @param {{x: number, y: number}} v0\n * @param {{x: number, y: number}} v1\n * @returns {{x: number, y: number}}\n */\nfunction angleBetween(v0, v1) {\n  const {\n    x: v0x,\n    y: v0y\n  } = v0;\n  const {\n    x: v1x,\n    y: v1y\n  } = v1;\n  const p = v0x * v1x + v0y * v1y;\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\n  const angle = sign * Math.acos(p / n);\n  return angle;\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.\n * @see https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\n *\n * @param {number} x1 the starting x position\n * @param {number} y1 the starting y position\n * @param {number} RX x-radius of the arc\n * @param {number} RY y-radius of the arc\n * @param {number} angle x-axis-rotation of the arc\n * @param {number} LAF large-arc-flag of the arc\n * @param {number} SF sweep-flag of the arc\n * @param {number} x the ending x position\n * @param {number} y the ending y position\n * @param {number} t the point distance\n * @returns {{x: number, y: number}} the requested point\n */\nfunction getPointAtArcSegmentLength(x1, y1, RX, RY, angle, LAF, SF, x, y, t) {\n  const {\n    abs,\n    sin,\n    cos,\n    sqrt,\n    PI\n  } = Math;\n  let rx = abs(RX);\n  let ry = abs(RY);\n  const xRot = (angle % 360 + 360) % 360;\n  const xRotRad = xRot * (PI / 180);\n  if (x1 === x && y1 === y) {\n    return {\n      x: x1,\n      y: y1\n    };\n  }\n  if (rx === 0 || ry === 0) {\n    return segmentLineFactory(x1, y1, x, y, t).point;\n  }\n  const dx = (x1 - x) / 2;\n  const dy = (y1 - y) / 2;\n  const transformedPoint = {\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy\n  };\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 + transformedPoint.y ** 2 / ry ** 2;\n  if (radiiCheck > 1) {\n    rx *= sqrt(radiiCheck);\n    ry *= sqrt(radiiCheck);\n  }\n  const cSquareNumerator = rx ** 2 * ry ** 2 - rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 + ry ** 2 * transformedPoint.x ** 2;\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * (rx * transformedPoint.y / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx)\n  };\n  const center = {\n    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,\n    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2\n  };\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry\n  };\n  const startAngle = angleBetween({\n    x: 1,\n    y: 0\n  }, startVector);\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry\n  };\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!SF && sweepAngle > 0) {\n    sweepAngle -= 2 * PI;\n  } else if (SF && sweepAngle < 0) {\n    sweepAngle += 2 * PI;\n  }\n  sweepAngle %= 2 * PI;\n  const alpha = startAngle + sweepAngle * t;\n  const ellipseComponentX = rx * cos(alpha);\n  const ellipseComponentY = ry * sin(alpha);\n  const point = {\n    x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,\n    y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y\n  };\n\n  // to be used later\n  // point.ellipticalArcStartAngle = startAngle;\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\n  // point.ellipticalArcAngle = alpha;\n\n  // point.ellipticalArcCenter = center;\n  // point.resultantRx = rx;\n  // point.resultantRy = ry;\n\n  return point;\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the shape minimum and maximum {x,y} coordinates of an A (arc-to) segment.\n *\n * @param {number} X1 the starting x position\n * @param {number} Y1 the starting y position\n * @param {number} RX x-radius of the arc\n * @param {number} RY y-radius of the arc\n * @param {number} angle x-axis-rotation of the arc\n * @param {number} LAF large-arc-flag of the arc\n * @param {number} SF sweep-flag of the arc\n * @param {number} X2 the ending x position\n * @param {number} Y2 the ending y position\n * @param {number} distance the point distance\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentArcFactory(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, distance) {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = X1;\n  let y = Y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y];\n  let t = 0;\n  let POINT = {\n    x: 0,\n    y: 0\n  };\n  let POINTS = [{\n    x,\n    y\n  }];\n  if (distanceIsNumber && distance <= 0) {\n    POINT = {\n      x,\n      y\n    };\n  }\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n    ({\n      x,\n      y\n    } = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, t));\n    POINTS = [...POINTS, {\n      x,\n      y\n    }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = {\n      x: X2,\n      y: Y2\n    };\n  }\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map(n => n.x)),\n      y: Math.min(...POINTS.map(n => n.y))\n    },\n    max: {\n      x: Math.max(...POINTS.map(n => n.x)),\n      y: Math.max(...POINTS.map(n => n.y))\n    }\n  };\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} c1x the first control point X\n * @param {number} c1y the first control point Y\n * @param {number} c2x the second control point X\n * @param {number} c2y the second control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number} t a [0-1] ratio\n * @returns {{x: number, y: number}} the cubic-bezier segment length\n */\nfunction getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t) {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 3 * x1 + 3 * t1 ** 2 * t * c1x + 3 * t1 * t ** 2 * c2x + t ** 3 * x2,\n    y: t1 ** 3 * y1 + 3 * t1 ** 2 * t * c1y + 3 * t1 * t ** 2 * c2y + t ** 3 * y2\n  };\n}\n\n/**\n * Returns the length of a C (cubic-bezier) segment\n * or an {x,y} point at a given length.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} c1x the first control point X\n * @param {number} c1y the first control point Y\n * @param {number} c2x the second control point X\n * @param {number} c2y the second control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number=} distance the point distance\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x2, y2, distance) {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = x1;\n  let y = y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y];\n  let t = 0;\n  let POINT = {\n    x: 0,\n    y: 0\n  };\n  let POINTS = [{\n    x,\n    y\n  }];\n  if (distanceIsNumber && distance <= 0) {\n    POINT = {\n      x,\n      y\n    };\n  }\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n    ({\n      x,\n      y\n    } = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t));\n    POINTS = [...POINTS, {\n      x,\n      y\n    }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = {\n      x: x2,\n      y: y2\n    };\n  }\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map(n => n.x)),\n      y: Math.min(...POINTS.map(n => n.y))\n    },\n    max: {\n      x: Math.max(...POINTS.map(n => n.x)),\n      y: Math.max(...POINTS.map(n => n.y))\n    }\n  };\n}\n\n/**\n * Returns the {x,y} coordinates of a point at a\n * given length of a quadratic-bezier segment.\n *\n * @see https://github.com/substack/point-at-length\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} cx the control point X\n * @param {number} cy the control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number} t a [0-1] ratio\n * @returns {{x: number, y: number}} the requested {x,y} coordinates\n */\nfunction getPointAtQuadSegmentLength(x1, y1, cx, cy, x2, y2, t) {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 2 * x1 + 2 * t1 * t * cx + t ** 2 * x2,\n    y: t1 ** 2 * y1 + 2 * t1 * t * cy + t ** 2 * y2\n  };\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a Q (quadratic-bezier) segment.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} qx the control point X\n * @param {number} qy the control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number=} distance the distance to point\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentQuadFactory(x1, y1, qx, qy, x2, y2, distance) {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = x1;\n  let y = y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y];\n  let t = 0;\n  let POINT = {\n    x: 0,\n    y: 0\n  };\n  let POINTS = [{\n    x,\n    y\n  }];\n  if (distanceIsNumber && distance <= 0) {\n    POINT = {\n      x,\n      y\n    };\n  }\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n    ({\n      x,\n      y\n    } = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t));\n    POINTS = [...POINTS, {\n      x,\n      y\n    }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  /* istanbul ignore else */\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = {\n      x: x2,\n      y: y2\n    };\n  }\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map(n => n.x)),\n      y: Math.min(...POINTS.map(n => n.y))\n    },\n    max: {\n      x: Math.max(...POINTS.map(n => n.x)),\n      y: Math.max(...POINTS.map(n => n.y))\n    }\n  };\n}\n\n/**\n * Returns a {x,y} point at a given length\n * of a shape, the shape total length and\n * the shape minimum and maximum {x,y} coordinates.\n *\n * @param {string | SVGPath.pathArray} pathInput the `pathArray` to look into\n * @param {number=} distance the length of the shape to look at\n * @returns {SVGPath.lengthFactory} the path length, point, min & max\n */\nfunction pathLengthFactory(pathInput, distance) {\n  const path = normalizePath(pathInput);\n  const distanceIsNumber = typeof distance === 'number';\n  let isM;\n  let data = [];\n  let pathCommand;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let seg;\n  let MIN = [];\n  let MAX = [];\n  let length = 0;\n  let min = {\n    x: 0,\n    y: 0\n  };\n  let max = min;\n  let point = min;\n  let POINT = min;\n  let LENGTH = 0;\n  for (let i = 0, ll = path.length; i < ll; i += 1) {\n    seg = path[i];\n    [pathCommand] = seg;\n    isM = pathCommand === 'M';\n    data = !isM ? [x, y, ...seg.slice(1)] : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg;\n      min = {\n        x: mx,\n        y: my\n      };\n      max = min;\n      length = 0;\n      if (distanceIsNumber && distance < 0.001) {\n        POINT = min;\n      }\n    } else if (pathCommand === 'L') {\n      ({\n        length,\n        min,\n        max,\n        point\n      } = segmentLineFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'A') {\n      ({\n        length,\n        min,\n        max,\n        point\n      } = segmentArcFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'C') {\n      ({\n        length,\n        min,\n        max,\n        point\n      } = segmentCubicFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'Q') {\n      ({\n        length,\n        min,\n        max,\n        point\n      } = segmentQuadFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      ({\n        length,\n        min,\n        max,\n        point\n      } = segmentLineFactory(...data, (distance || 0) - LENGTH));\n    }\n    if (distanceIsNumber && LENGTH < distance && LENGTH + length >= distance) {\n      POINT = point;\n    }\n    MAX = [...MAX, max];\n    MIN = [...MIN, min];\n    LENGTH += length;\n    [x, y] = pathCommand !== 'Z' ? seg.slice(-2) : [mx, my];\n  }\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = {\n      x,\n      y\n    };\n  }\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...MIN.map(n => n.x)),\n      y: Math.min(...MIN.map(n => n.y))\n    },\n    max: {\n      x: Math.max(...MAX.map(n => n.x)),\n      y: Math.max(...MAX.map(n => n.y))\n    }\n  };\n}\n\n/**\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\n *\n * The `normalizePath` version is lighter, faster, more efficient and more accurate\n * with paths that are not `curveArray`.\n *\n * @param {string | SVGPath.pathArray} pathInput the target `pathArray`\n * @returns {number} the shape total length\n */\nfunction getTotalLength(pathInput) {\n  return pathLengthFactory(pathInput).length;\n}\n\n/**\n * Returns [x,y] coordinates of a point at a given length of a shape.\n *\n * @param {string | SVGPath.pathArray} pathInput the `pathArray` to look into\n * @param {number} distance the length of the shape to look at\n * @returns {{x: number, y: number}} the requested {x, y} point coordinates\n */\nfunction getPointAtLength(pathInput, distance) {\n  return pathLengthFactory(pathInput, distance).point;\n}\n\n/**\n * d3-polygon-area\n * https://github.com/d3/d3-polygon\n *\n * Returns the area of a polygon.\n *\n * @param {number[][]} polygon an array of coordinates\n * @returns {number} the polygon area\n */\nfunction polygonArea(polygon) {\n  const n = polygon.length;\n  let i = -1;\n  let a;\n  let b = polygon[n - 1];\n  let area = 0;\n\n  /* eslint-disable-next-line */\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n  return area / 2;\n}\n\n/**\n * d3-polygon-length\n * https://github.com/d3/d3-polygon\n *\n * Returns the perimeter of a polygon.\n *\n * @param {[number,number][]} polygon an array of coordinates\n * @returns {number} the polygon length\n */\nfunction polygonLength(polygon) {\n  return polygon.reduce((length, point, i) => {\n    if (i) {\n      return length + distanceSquareRoot(polygon[i - 1], point);\n    }\n    return 0;\n  }, 0);\n}\n\n/**\n * A global namespace for epsilon.\n *\n * @type {number}\n */\nconst epsilon = 1e-9;\n\n/**\n * Coordinates Interpolation Function.\n *\n * @param {number[][]} a start coordinates\n * @param {number[][]} b end coordinates\n * @param {string} l amount of coordinates\n * @param {number} v progress\n * @returns {number[][]} the interpolated coordinates\n */\nfunction coords(a, b, l, v) {\n  const points = [];\n  for (let i = 0; i < l; i += 1) {\n    // for each point\n    points[i] = [];\n    for (let j = 0; j < 2; j += 1) {\n      // each point coordinate\n      // eslint-disable-next-line no-bitwise\n      points[i].push(((a[i][j] + (b[i][j] - a[i][j]) * v) * 1000 >> 0) / 1000);\n    }\n  }\n  return points;\n}\n\n/* SVGMorph = {\n  property: 'path',\n  defaultValue: [],\n  interpolators: {numbers,coords} },\n  functions = { prepareStart, prepareProperty, onStart, crossCheck }\n} */\n\n// Component functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartSVGMorph(tweenProp) {\n  if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      const path1 = a.polygon;\n      const path2 = b.polygon;\n      const len = path2.length;\n      elem.setAttribute('d', v === 1 ? b.original : `M${coords(path1, path2, len, v).join('L')}Z`);\n    };\n  }\n}\n\n// Component Util\n// original script flubber\n// https://github.com/veltman/flubber\n\n/**\n * Returns an existing polygon or false if it's not a polygon.\n * @param {SVGPath.pathArray} pathArray target `pathArray`\n * @returns {KUTE.exactPolygon | false} the resulted polygon\n */\nfunction exactPolygon(pathArray) {\n  const polygon = [];\n  const pathlen = pathArray.length;\n  let segment = [];\n  let pathCommand = '';\n  if (!pathArray.length || pathArray[0][0] !== 'M') {\n    return false;\n  }\n  for (let i = 0; i < pathlen; i += 1) {\n    segment = pathArray[i];\n    [pathCommand] = segment;\n    if (pathCommand === 'M' && i || pathCommand === 'Z') {\n      break; // !!\n    } else if ('ML'.includes(pathCommand)) {\n      polygon.push([segment[1], segment[2]]);\n    } else {\n      return false;\n    }\n  }\n  return pathlen ? {\n    polygon\n  } : false;\n}\n\n/**\n * Returns a new polygon polygon.\n * @param {SVGPath.pathArray} parsed target `pathArray`\n * @param {number} maxLength the maximum segment length\n * @returns {KUTE.exactPolygon} the resulted polygon\n */\nfunction approximatePolygon(parsed, maxLength) {\n  const ringPath = splitPath(parsed)[0];\n  const normalPath = normalizePath(ringPath);\n  const pathLength = getTotalLength(normalPath);\n  const polygon = [];\n  let numPoints = 3;\n  let point;\n  if (maxLength && !Number.isNaN(maxLength) && +maxLength > 0) {\n    numPoints = Math.max(numPoints, Math.ceil(pathLength / maxLength));\n  }\n  for (let i = 0; i < numPoints; i += 1) {\n    point = getPointAtLength(normalPath, pathLength * i / numPoints);\n    polygon.push([point.x, point.y]);\n  }\n\n  // Make all rings clockwise\n  if (polygonArea(polygon) > 0) {\n    polygon.reverse();\n  }\n  return {\n    polygon,\n    skipBisect: true\n  };\n}\n\n/**\n * Parses a path string and returns a polygon array.\n * @param {string} str path string\n * @param {number} maxLength maximum amount of points\n * @returns {KUTE.exactPolygon} the polygon array we need\n */\nfunction pathStringToPolygon(str, maxLength) {\n  const parsed = normalizePath(str);\n  return exactPolygon(parsed) || approximatePolygon(parsed, maxLength);\n}\n\n/**\n * Rotates a polygon to better match its pair.\n * @param {KUTE.polygonMorph} polygon the target polygon\n * @param {KUTE.polygonMorph} vs the reference polygon\n */\nfunction rotatePolygon(polygon, vs) {\n  const len = polygon.length;\n  let min = Infinity;\n  let bestOffset;\n  let sumOfSquares = 0;\n  let spliced;\n  let d;\n  let p;\n  for (let offset = 0; offset < len; offset += 1) {\n    sumOfSquares = 0;\n    for (let i = 0; i < vs.length; i += 1) {\n      p = vs[i];\n      d = distanceSquareRoot(polygon[(offset + i) % len], p);\n      sumOfSquares += d * d;\n    }\n    if (sumOfSquares < min) {\n      min = sumOfSquares;\n      bestOffset = offset;\n    }\n  }\n  if (bestOffset) {\n    spliced = polygon.splice(0, bestOffset);\n    polygon.splice(polygon.length, 0, ...spliced);\n  }\n}\n\n/**\n * Sample additional points for a polygon to better match its pair.\n * @param {KUTE.polygonObject} polygon the target polygon\n * @param {number} numPoints the amount of points needed\n */\nfunction addPoints(polygon, numPoints) {\n  const desiredLength = polygon.length + numPoints;\n  const step = polygonLength(polygon) / numPoints;\n  let i = 0;\n  let cursor = 0;\n  let insertAt = step / 2;\n  let a;\n  let b;\n  let segment;\n  while (polygon.length < desiredLength) {\n    a = polygon[i];\n    b = polygon[(i + 1) % polygon.length];\n    segment = distanceSquareRoot(a, b);\n    if (insertAt <= cursor + segment) {\n      polygon.splice(i + 1, 0, segment ? midPoint(a, b, (insertAt - cursor) / segment) : a.slice(0));\n      insertAt += step;\n    } else {\n      cursor += segment;\n      i += 1;\n    }\n  }\n}\n\n/**\n * Split segments of a polygon until it reaches a certain\n * amount of points.\n * @param {number[][]} polygon the target polygon\n * @param {number} maxSegmentLength the maximum amount of points\n */\nfunction bisect(polygon, maxSegmentLength = Infinity) {\n  let a = [];\n  let b = [];\n  for (let i = 0; i < polygon.length; i += 1) {\n    a = polygon[i];\n    b = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];\n\n    // Could splice the whole set for a segment instead, but a bit messy\n    while (distanceSquareRoot(a, b) > maxSegmentLength) {\n      b = midPoint(a, b, 0.5);\n      polygon.splice(i + 1, 0, b);\n    }\n  }\n}\n\n/**\n * Checks the validity of a polygon.\n * @param {KUTE.polygonMorph} polygon the target polygon\n * @returns {boolean} the result of the check\n */\nfunction validPolygon(polygon) {\n  return Array.isArray(polygon) && polygon.every(point => Array.isArray(point) && point.length === 2 && !Number.isNaN(point[0]) && !Number.isNaN(point[1]));\n}\n\n/**\n * Returns a new polygon and its length from string or another `Array`.\n * @param {KUTE.polygonMorph | string} input the target polygon\n * @param {number} maxSegmentLength the maximum amount of points\n * @returns {KUTE.polygonMorph} normalized polygon\n */\nfunction getPolygon(input, maxSegmentLength) {\n  let skipBisect;\n  let polygon;\n  if (typeof input === 'string') {\n    const converted = pathStringToPolygon(input, maxSegmentLength);\n    ({\n      polygon,\n      skipBisect\n    } = converted);\n  } else if (!Array.isArray(input)) {\n    throw Error(`${invalidPathValue}: ${input}`);\n  }\n\n  /** @type {KUTE.polygonMorph} */\n  const points = [...polygon];\n  if (!validPolygon(points)) {\n    throw Error(`${invalidPathValue}: ${points}`);\n  }\n\n  // TODO skip this test to avoid scale issues?\n  // Chosen epsilon (1e-6) is problematic for small coordinate range, we now use 1e-9\n  if (points.length > 1 && distanceSquareRoot(points[0], points[points.length - 1]) < epsilon) {\n    points.pop();\n  }\n  if (!skipBisect && maxSegmentLength && !Number.isNaN(maxSegmentLength) && +maxSegmentLength > 0) {\n    bisect(points, maxSegmentLength);\n  }\n  return points;\n}\n\n/**\n * Returns two new polygons ready to tween.\n * @param {string} path1 the first path string\n * @param {string} path2 the second path string\n * @param {number} precision the morphPrecision option value\n * @returns {KUTE.polygonMorph[]} the two polygons\n */\nfunction getInterpolationPoints(path1, path2, precision) {\n  const morphPrecision = precision || defaultOptions$1.morphPrecision;\n  const fromRing = getPolygon(path1, morphPrecision);\n  const toRing = getPolygon(path2, morphPrecision);\n  const diff = fromRing.length - toRing.length;\n  addPoints(fromRing, diff < 0 ? diff * -1 : 0);\n  addPoints(toRing, diff > 0 ? diff : 0);\n  rotatePolygon(fromRing, toRing);\n  return [roundPath(fromRing), roundPath(toRing)];\n}\n\n// Component functions\n/**\n * Returns the current `d` attribute value.\n * @returns {string} the `d` attribute value\n */\nfunction getSVGMorph( /* tweenProp */\n) {\n  return this.element.getAttribute('d');\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string | KUTE.polygonObject} value the property value\n * @returns {KUTE.polygonObject} the property tween object\n */\nfunction prepareSVGMorph( /* tweenProp */_, value) {\n  const pathObject = {};\n  // remove newlines, they brake JSON strings sometimes\n  const pathReg = new RegExp('\\\\n', 'ig');\n  let elem = null;\n  if (value instanceof SVGPathElement) {\n    elem = value;\n  } else if (/^\\.|^#/.test(value)) {\n    elem = selector(value);\n  }\n\n  // first make sure we return pre-processed values\n  if (typeof value === 'object' && value.polygon) {\n    return value;\n  }\n  if (elem && ['path', 'glyph'].includes(elem.tagName)) {\n    pathObject.original = elem.getAttribute('d').replace(pathReg, '');\n    // maybe it's a string path already\n  } else if (!elem && typeof value === 'string') {\n    pathObject.original = value.replace(pathReg, '');\n  }\n  return pathObject;\n}\n\n/**\n * Enables the `to()` method by preparing the tween object in advance.\n * @param {string} prop the `path` property name\n */\nfunction crossCheckSVGMorph(prop) {\n  if (this.valuesEnd[prop]) {\n    const pathArray1 = this.valuesStart[prop].polygon;\n    const pathArray2 = this.valuesEnd[prop].polygon;\n    // skip already processed paths\n    // allow the component to work with pre-processed values\n    if (!pathArray1 || !pathArray2 || pathArray1.length !== pathArray2.length) {\n      const p1 = this.valuesStart[prop].original;\n      const p2 = this.valuesEnd[prop].original;\n      // process morphPrecision\n      const morphPrecision = this._morphPrecision ? parseInt(this._morphPrecision, 10) : defaultOptions$1.morphPrecision;\n      const [path1, path2] = getInterpolationPoints(p1, p2, morphPrecision);\n      this.valuesStart[prop].polygon = path1;\n      this.valuesEnd[prop].polygon = path2;\n    }\n  }\n}\n\n// All Component Functions\nconst svgMorphFunctions = {\n  prepareStart: getSVGMorph,\n  prepareProperty: prepareSVGMorph,\n  onStart: onStartSVGMorph,\n  crossCheck: crossCheckSVGMorph\n};\n\n// Component Full\nconst SVGMorph = {\n  component: 'svgMorph',\n  property: 'path',\n  defaultValue: [],\n  Interpolate: coords,\n  defaultOptions: {\n    morphPrecision: 10\n  },\n  functions: svgMorphFunctions,\n  // Export utils to global for faster execution\n  Util: {\n    // component\n    addPoints,\n    bisect,\n    getPolygon,\n    validPolygon,\n    getInterpolationPoints,\n    pathStringToPolygon,\n    distanceSquareRoot,\n    midPoint,\n    approximatePolygon,\n    rotatePolygon,\n    // svg-path-commander\n    pathToString,\n    pathToCurve,\n    getTotalLength,\n    getPointAtLength,\n    polygonArea,\n    roundPath\n  }\n};\nconst Components = {\n  EssentialBoxModel: BoxModelEssential,\n  ColorsProperties: colorProperties,\n  HTMLAttributes: htmlAttributes,\n  OpacityProperty,\n  TextWriteProp: TextWrite,\n  TransformFunctions,\n  SVGDraw: SvgDrawProperty,\n  SVGMorph\n};\n\n// init components\nObject.keys(Components).forEach(component => {\n  const compOps = Components[component];\n  Components[component] = new Animation(compOps);\n});\nvar version = \"2.2.4\";\n\n// @ts-ignore\n\n/**\n * A global namespace for library version.\n * @type {string}\n */\nconst Version = version;\n\n// KUTE.js standard distribution version\n\nconst KUTE = {\n  Animation,\n  Components,\n  // Tween Interface\n  Tween,\n  fromTo,\n  to,\n  // Tween Collection\n  TweenCollection,\n  allFromTo,\n  allTo,\n  // Tween Interface\n\n  Objects,\n  Util,\n  Easing,\n  CubicBezier,\n  Render,\n  Interpolate: interpolate,\n  Process,\n  Internals: internals,\n  Selector: selector,\n  Version\n};\nexport { KUTE as default };","map":{"version":3,"names":["CubicBezier","constructor","x1","y1","x2","y2","functionName","p1x","p1y","p2x","p2y","cx","bx","ax","cy","by","ay","BezierEasing","t","sampleCurveY","solveCurveX","Object","defineProperty","writable","name","sampleCurveX","sampleCurveDerivativeX","x","epsilon","t2","d2","i","Math","abs","t0","t1","version$1","Version$1","assign","Version","KEC","Tweens","gl0bal","global","window","self","globalObject","interpolate","onStart","performanceNow","process","hrtime","time","performance","undefined","now","bind","Date","getTime","Time","Tick","Ticker","length","update","splice","requestAnimationFrame","stop","setTimeout","cancelAnimationFrame","keys","forEach","obj","prop","Render","blob","_KUTE","supportedProperties","defaultValues","defaultOptions$1","duration","delay","easing","repeat","repeatDelay","yoyo","resetStart","offset","prepareProperty","prepareStart","crossCheck","onComplete","linkProperty","Objects","defaultOptions","Util","add","tw","push","remove","indexOf","getAll","removeAll","linkInterpolation","component","componentLink","componentProps","fnObj","valuesEnd","some","includes","j","propObject","internals","getInlineStyle","el","style","css","cssText","replace","split","transformObject","arrayFn","cs","test","tps","tpi","tpv","tp","tv","getStyleForProperty","elem","propertyName","result","styleAttribute","computedStyle","getComputedStyle","currentStyle","styleValue","prepareObject","fn","propertiesObject","valuesStart","prepareComponent","supportComponent","tweenCategory","tweenProp","call","getStartValues","startValues","element","componentStart","current","Process","connect","tween","processEasing","Easing","linear","easingSinusoidalIn","easingSinusoidalOut","easingSinusoidalInOut","easingQuadraticIn","easingQuadraticOut","easingQuadraticInOut","easingCubicIn","easingCubicOut","easingCubicInOut","easingQuarticIn","easingQuarticOut","easingQuarticInOut","easingQuinticIn","easingQuinticOut","easingQuinticInOut","easingExponentialIn","easingExponentialOut","easingExponentialInOut","easingCircularIn","easingCircularOut","easingCircularInOut","easingBackIn","easingBackOut","easingBackInOut","processBezierEasing","bz","selector","multi","requestedElem","itemsArray","Array","every","Element","HTMLCollection","NodeList","document","querySelectorAll","querySelector","e","TypeError","queueStart","TweenBase","targetElement","startObject","endObject","opsObject","playing","_startTime","_startFired","options","_resetStart","_easing","_duration","_delay","op","internalOption","easingFnName","easingFn","start","_onStart","_onStop","close","toClose","chain","args","_chain","concat","stopChainedTweens","T","elapsed","progress","_onUpdate","_onComplete","map","Tween","slice","checkProp","paused","_pauseTime","_repeat","_repeatDelay","_repeatOption","valuesRepeat","_yoyo","_reversed","endProp","reverse","resume","_onResume","pause","_onPause","reverseProp","tmp","Number","isFinite","TweenCollection","els","vS","vE","Options","TweenConstructor","tweens","Ops","from","Error","lastTween","removeTweens","getMaxDuration","durations","max","TweenConstructor$1","to","optionsObj","fromTo","allTo","elements","allFromTo","Animation","Component","property","propertyInfo","ComponentName","Functions","Category","category","Property","Length","properties","subProperties","defaultValue","supports","dv","functions","ofn","Interpolate","fni","compIntObj","sfn","fnu","trueDimension","dimValue","isAngle","intValue","parseInt","mUnits","theUnit","mIndex","v","u","numbers","a","b","A","B","boxModelOnStart","getBoxModel","prepareBoxModel","value","boxValue","offsetProp","essentialBoxProps","essentialBoxPropsValues","top","left","width","height","essentialBoxOnStart","essentialBoxModelFunctions","BoxModelEssential","hexToRGB","hex","hexShorthand","HEX","_","r","g","exec","trueColor","colorString","vrgb","colorAlpha","parseFloat","fromHex","siteHead","getElementsByTagName","color","webColor","colors","_c","ep","cm","rgb","rgba","c","onStartColors","supportedColors","defaultColors","colorsOnStart","getColor","prepareColor","colorFunctions","colorProperties","attributes","onStartAttr","attr","oneAttr","svgColors","replaceUppercase","toLowerCase","getAttr","attrStartValues","attribute","currentValue","getAttribute","prepareAttr","attrObj","attributesObject","p","regex","unit","suffix","_p","setAttribute","htmlAttributes","attrFunctions","fill","stroke","opacity","onStartOpacity","getOpacity","prepareOpacity","opacityFunctions","OpacityProperty","lowerCaseAlpha","String","upperCaseAlpha","toUpperCase","nonAlpha","numeric","alphaNumeric","allTypes","charSet","alpha","upper","symbols","alphanumeric","all","onStartWrite","text","chars","_textChars","charsets","textChars","initialText","endText","finalText","firstLetterA","substring","firstLetterB","pointer","random","min","innerHTML","number","wrapContentsSpan","classNAME","textWriteWrapper","newElem","createElement","className","children","elementInnerHTML","appendChild","outerHTML","getTextPartsArray","elementsArray","len","textParts","remainingMarkup","wrapperParts","currentChild","childOuter","unTaggedContent","classList","contains","unTaggedRemaining","setSegments","target","newText","oldTargetSegs","newTargetSegs","s","join","createTextTweens","ops","TweenContructor","segs","oldTargets","getElementsByClassName","newTargets","textTween","totalDelay","startTweens","getWrite","prepareText","textWriteFunctions","TextWrite","perspective","translate3d","translateArray","rotate3d","rotateStr","translate","rotate","scale","skew","skewArray","onStartTransform","getTransform","prepareTransform","prepAxis","rotateArray","arrayFunctions","pv","propId","fnId","fnLen","fnArray","fnIndex","fnAxis","crossCheckTransform","transformFunctions","supportedTransformProperties","defaultTransformValues","translateX","translateY","translateZ","rotateX","rotateY","rotateZ","skewX","skewY","TransformFunctions","onStartDraw","pathLength","l","end","dashOne","strokeDashoffset","strokeDasharray","percent","getRectLength","w","h","getPolyLength","points","coord","isNaN","dist","c1","c2","sqrt","tagName","getLineLength","getCircleLength","PI","getEllipseLength","rx","ry","wid","getTotalLength$1","getDraw","getTotalLength","dasharray","trim","resetDraw","getDrawValue","prepareDraw","svgDrawFunctions","SvgDrawProperty","fixArc","path","allPathCommands","shift","segment","ni","paramsCount","m","q","z","isPathArray","isArray","seg","lk","isAbsoluteArray","isNormalizedArray","pc","isCurveArray","clonePath","finalizeSegment","pathCommand","pathValue","segmentStart","LK","data","segments","error","scanFlag","index","code","charCodeAt","param","err","isDigit","invalidPathValue","scanParam","zeroFirst","hasCeiling","hasDecimal","hasDot","ch","isSpace","specialSpaces","skipSpaces","isPathCommand","isDigitStart","isArcCommand","scanSegment","cmdCode","reqParams","PathParser","pathString","parsePathString","pathInput","pathToAbsolute","y","mx","my","values","absCommand","absoluteSegment","absValues","n","segLength","normalizeSegment","params","px1","py1","px2","py2","qx","qy","nqx","nqy","paramsParser","normalizePath","ii","seglen","rotateVector","rad","X","cos","sin","Y","arcToCubic","X1","Y1","RX","RY","angle","LAF","SF","X2","Y2","recursive","d120","res","xy","f1","f2","rx2","ry2","k","asin","df","f2old","x2old","y2old","s1","s2","tan","hx","hy","m1","m2","m3","m4","newres","quadToCubic","r13","r23","midPoint","distanceSquareRoot","segmentLineFactory","distance","point","lineToCubic","p0","p1","p2","p3","p4","p5","p6","seg1","cp1","seg2","cp2","segmentToCubic","px","py","pathToCurve","origin","round","roundPath","roundOption","pow","pi","pathToString","splitPath","composite","angleBetween","v0","v1","v0x","v0y","v1x","v1y","sign","acos","getPointAtArcSegmentLength","xRot","xRotRad","dx","dy","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","startAngle","endVector","sweepAngle","ellipseComponentX","ellipseComponentY","segmentArcFactory","distanceIsNumber","LENGTH","prev","cur","POINT","POINTS","sampleSize","getPointAtCubicSegmentLength","c1x","c1y","c2x","c2y","segmentCubicFactory","getPointAtQuadSegmentLength","segmentQuadFactory","pathLengthFactory","isM","MIN","MAX","ll","getPointAtLength","polygonArea","polygon","area","polygonLength","reduce","coords","onStartSVGMorph","path1","path2","original","exactPolygon","pathArray","pathlen","approximatePolygon","parsed","maxLength","ringPath","normalPath","numPoints","ceil","skipBisect","pathStringToPolygon","str","rotatePolygon","vs","Infinity","bestOffset","sumOfSquares","spliced","d","addPoints","desiredLength","step","cursor","insertAt","bisect","maxSegmentLength","validPolygon","getPolygon","input","converted","pop","getInterpolationPoints","precision","morphPrecision","fromRing","toRing","diff","getSVGMorph","prepareSVGMorph","pathObject","pathReg","RegExp","SVGPathElement","crossCheckSVGMorph","pathArray1","pathArray2","_morphPrecision","svgMorphFunctions","SVGMorph","Components","EssentialBoxModel","ColorsProperties","HTMLAttributes","TextWriteProp","SVGDraw","compOps","version","KUTE","Internals","Selector","default"],"sources":["C:/Users/Noel/Documents/GitHub/every-so-often/node_modules/kute.js/dist/kute.esm.js"],"sourcesContent":["/*!\n* KUTE.js Standard v2.2.4 (http://thednp.github.io/kute.js)\n* Copyright 2015-2022 Â© thednp\n* Licensed under MIT (https://github.com/thednp/kute.js/blob/master/LICENSE)\n*/\n/**\r\n * Creates cubic-bezier easing functions for animation engines.\r\n * @see http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h\r\n * \r\n *\r\n * @class\r\n */\r\nclass CubicBezier {\r\n  /**\r\n   * @constructor\r\n   * @param {number} x1 - first point horizontal position\r\n   * @param {number} y1 - first point vertical position\r\n   * @param {number} x2 - second point horizontal position\r\n   * @param {number} y2 - second point vertical position\r\n   * @param {string=} functionName - an optional function name\r\n   * @returns {(t: number) => number} a new CubicBezier easing function\r\n   */\r\n  constructor(x1, y1, x2, y2, functionName) {\r\n    // pre-calculate the polynomial coefficients\r\n    // First and last control points are implied to be (0.0, 0.0) and (1.0, 1.0)\r\n    const p1x = x1 || 0;\r\n    const p1y = y1 || 0;\r\n    const p2x = x2 || 1;\r\n    const p2y = y2 || 1;\r\n  \r\n    /** @type {number} */\r\n    this.cx = 3 * p1x;\r\n  \r\n    /** @type {number} */\r\n    this.bx = 3 * (p2x - p1x) - this.cx;\r\n\r\n    /** @type {number} */\r\n    this.ax = 1 - this.cx - this.bx;\r\n    \r\n    /** @type {number} */\r\n    this.cy = 3 * p1y;\r\n  \r\n    /** @type {number} */\r\n    this.by = 3 * (p2y - p1y) - this.cy;\r\n  \r\n    /** @type {number} */\r\n    this.ay = 1 - this.cy - this.by;\r\n    \r\n    /** @type {(t: number) => number} */\r\n    const BezierEasing = (t) => this.sampleCurveY(this.solveCurveX(t));\r\n\r\n    // this function needs a name\r\n    Object.defineProperty(BezierEasing, 'name', { writable: true });\r\n    BezierEasing.name = functionName || `cubic-bezier(${[p1x, p1y, p2x, p2y]})`;\r\n\r\n    return BezierEasing;\r\n  }\r\n\r\n  /**\r\n   * @param {number} t - progress [0-1]\r\n   * @return {number} - sampled X value\r\n   */\r\n  sampleCurveX(t) {\r\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\r\n  }\r\n\r\n  /**\r\n   * @param {number} t - progress [0-1]\r\n   * @return {number} - sampled Y value\r\n   */\r\n  sampleCurveY(t) {\r\n    return ((this.ay * t + this.by) * t + this.cy) * t;\r\n  }\r\n\r\n  /**\r\n   * @param {number} t - progress [0-1]\r\n   * @return {number} - sampled curve derivative X value\r\n   */\r\n  sampleCurveDerivativeX(t) {\r\n    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x - progress [0-1]\r\n   * @return {number} - solved curve X value\r\n   */\r\n  solveCurveX(x) {\r\n    // Set Precision\r\n    const epsilon = 1e-6;\r\n\r\n    // Skip values out of range\r\n    if (x <= 0) return 0;\r\n    if (x >= 1) return 1;\r\n\r\n    let t2 = x;\r\n    let x2 = 0;\r\n    let d2 = 0;\r\n\r\n    // First try a few iterations of Newton's method\r\n    // -- usually very fast.\r\n    for (let i = 0; i < 8; i += 1) {\r\n      x2 = this.sampleCurveX(t2) - x;\r\n      if (Math.abs(x2) < epsilon) return t2;\r\n      d2 = this.sampleCurveDerivativeX(t2);\r\n      /* istanbul ignore next */\r\n      if (Math.abs(d2) < epsilon) break;\r\n      t2 -= x2 / d2;\r\n    }\r\n\r\n    // No solution found - use bi-section\r\n    let t0 = 0;\r\n    let t1 = 1;\r\n    t2 = x;\r\n\r\n    while (t0 < t1) {\r\n      x2 = this.sampleCurveX(t2);\r\n      if (Math.abs(x2 - x) < epsilon) return t2;\r\n      if (x > x2) t0 = t2;\r\n      else t1 = t2;\r\n\r\n      t2 = (t1 - t0) * 0.5 + t0;\r\n    }\r\n\r\n    // Give up\r\n    /* istanbul ignore next */\r\n    return t2;\r\n  }\r\n}\n\nvar version$1 = \"1.0.1\";\n\n/**\r\n * A global namespace for library version.\r\n * @type {string}\r\n */\r\nconst Version$1 = version$1;\n\n/** @typedef {import('../types/index')} */\r\n\r\nObject.assign(CubicBezier, { Version: Version$1 });\n\n/**\n * The KUTE.js Execution Context\n */\nconst KEC = {};\n\nconst Tweens = [];\n\nlet gl0bal;\n\nif (typeof global !== 'undefined') gl0bal = global;\nelse if (typeof window !== 'undefined') gl0bal = window.self;\nelse gl0bal = {};\n\nconst globalObject = gl0bal;\n\n// KUTE.js INTERPOLATE FUNCTIONS\n// =============================\nconst interpolate = {};\n\n// schedule property specific function on animation start\n// link property update function to KUTE.js execution context\nconst onStart = {};\n\n// Include a performance.now polyfill.\n// source https://github.com/tweenjs/tween.js/blob/master/src/Now.ts\nlet performanceNow;\n\n// In node.js, use process.hrtime.\n// eslint-disable-next-line\n// @ts-ignore\r\nif (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {\n  performanceNow = () => {\n    // eslint-disable-next-line\n\t\t// @ts-ignore\r\n    const time = process.hrtime();\n\n    // Convert [seconds, nanoseconds] to milliseconds.\n    return time[0] * 1000 + time[1] / 1000000;\n  };\n} else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {\n  // In a browser, use self.performance.now if it is available.\n  // This must be bound, because directly assigning this function\n  // leads to an invocation exception in Chrome.\n  performanceNow = self.performance.now.bind(self.performance);\n} else if (typeof Date !== 'undefined' && Date.now) {\n  // Use Date.now if it is available.\n  performanceNow = Date.now;\n} else {\n  // Otherwise, use 'new Date().getTime()'.\n  performanceNow = () => new Date().getTime();\n}\n\nconst now = performanceNow;\n\nconst Time = {};\nTime.now = now;\n\n// eslint-disable-next-line import/no-mutable-exports -- impossible to satisfy\nlet Tick = 0;\n\n/**\n *\n * @param {number | Date} time\n */\nconst Ticker = (time) => {\n  let i = 0;\n  while (i < Tweens.length) {\n    if (Tweens[i].update(time)) {\n      i += 1;\n    } else {\n      Tweens.splice(i, 1);\n    }\n  }\n  Tick = requestAnimationFrame(Ticker);\n};\n\n// stop requesting animation frame\nfunction stop() {\n  setTimeout(() => { // re-added for #81\n    if (!Tweens.length && Tick) {\n      cancelAnimationFrame(Tick);\n      Tick = null;\n      Object.keys(onStart).forEach((obj) => {\n        if (typeof (onStart[obj]) === 'function') {\n          if (KEC[obj]) delete KEC[obj];\n        } else {\n          Object.keys(onStart[obj]).forEach((prop) => {\n            if (KEC[prop]) delete KEC[prop];\n          });\n        }\n      });\n\n      Object.keys(interpolate).forEach((i) => {\n        if (KEC[i]) delete KEC[i];\n      });\n    }\n  }, 64);\n}\n\n// render update functions\n// =======================\nconst Render = {\n  Tick, Ticker, Tweens, Time,\n};\nObject.keys(Render).forEach((blob) => {\n  if (!KEC[blob]) {\n    KEC[blob] = blob === 'Time' ? Time.now : Render[blob];\n  }\n});\n\nglobalObject._KUTE = KEC;\n\n// all supported properties\nconst supportedProperties = {};\n\nconst defaultValues = {};\n\nconst defaultOptions$1 = {\n  duration: 700,\n  delay: 0,\n  easing: 'linear',\n  repeat: 0,\n  repeatDelay: 0,\n  yoyo: false,\n  resetStart: false,\n  offset: 0,\n};\n\n// used in preparePropertiesObject\nconst prepareProperty = {};\n\n// check current property value when .to() method is used\nconst prepareStart = {};\n\n// checks for differences between the processed start and end values,\n// can be set to make sure start unit and end unit are same,\n// stack transforms, process SVG paths,\n// any type of post processing the component needs\nconst crossCheck = {};\n\n// schedule property specific function on animation complete\nconst onComplete = {};\n\n// link properties to interpolate functions\nconst linkProperty = {};\n\nconst Objects = {\n  supportedProperties,\n  defaultValues,\n  defaultOptions: defaultOptions$1,\n  prepareProperty,\n  prepareStart,\n  crossCheck,\n  onStart,\n  onComplete,\n  linkProperty,\n};\n\n// util - a general object for utils like rgbToHex, processEasing\nconst Util = {};\n\n/**\n * KUTE.add(Tween)\n *\n * @param {KUTE.Tween} tw a new tween to add\n */\nconst add = (tw) => Tweens.push(tw);\n\n/**\n * KUTE.remove(Tween)\n *\n * @param {KUTE.Tween} tw a new tween to add\n */\nconst remove = (tw) => {\n  const i = Tweens.indexOf(tw);\n  if (i !== -1) Tweens.splice(i, 1);\n};\n\n/**\n * KUTE.add(Tween)\n *\n * @return {KUTE.Tween[]} tw a new tween to add\n */\nconst getAll = () => Tweens;\n\n/**\n * KUTE.removeAll()\n */\nconst removeAll = () => { Tweens.length = 0; };\n\n/**\n * linkInterpolation\n * @this {KUTE.Tween}\n */\nfunction linkInterpolation() { // DON'T change\n  Object.keys(linkProperty).forEach((component) => {\n    const componentLink = linkProperty[component];\n    const componentProps = supportedProperties[component];\n\n    Object.keys(componentLink).forEach((fnObj) => {\n      if (typeof (componentLink[fnObj]) === 'function' // ATTR, colors, scroll, boxModel, borderRadius\n          && Object.keys(this.valuesEnd).some((i) => (componentProps && componentProps.includes(i))\n          || (i === 'attr' && Object.keys(this.valuesEnd[i]).some((j) => componentProps && componentProps.includes(j))))) {\n        if (!KEC[fnObj]) KEC[fnObj] = componentLink[fnObj];\n      } else {\n        Object.keys(this.valuesEnd).forEach((prop) => {\n          const propObject = this.valuesEnd[prop];\n          if (propObject instanceof Object) {\n            Object.keys(propObject).forEach((i) => {\n              if (typeof (componentLink[i]) === 'function') { // transformCSS3\n                if (!KEC[i]) KEC[i] = componentLink[i];\n              } else {\n                Object.keys(componentLink[fnObj]).forEach((j) => {\n                  if (componentLink[i] && typeof (componentLink[i][j]) === 'function') { // transformMatrix\n                    if (!KEC[j]) KEC[j] = componentLink[i][j];\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n  });\n}\n\nconst internals = {\n  add,\n  remove,\n  getAll,\n  removeAll,\n  stop,\n  linkInterpolation,\n};\n\n/**\n * getInlineStyle\n * Returns the transform style for element from\n * cssText. Used by for the `.to()` static method.\n *\n * @param {Element} el target element\n * @returns {object}\n */\nfunction getInlineStyle(el) {\n  // if the scroll applies to `window` it returns as it has no styling\n  if (!el.style) return false;\n  // the cssText | the resulting transform object\n  const css = el.style.cssText.replace(/\\s/g, '').split(';');\n  const transformObject = {};\n  const arrayFn = ['translate3d', 'translate', 'scale3d', 'skew'];\n\n  css.forEach((cs) => {\n    if (/transform/i.test(cs)) {\n      // all transform properties\n      const tps = cs.split(':')[1].split(')');\n      tps.forEach((tpi) => {\n        const tpv = tpi.split('(');\n        const tp = tpv[0];\n        // each transform property\n        const tv = tpv[1];\n        if (!/matrix/.test(tp)) {\n          transformObject[tp] = arrayFn.includes(tp) ? tv.split(',') : tv;\n        }\n      });\n    }\n  });\n\n  return transformObject;\n}\n\n/**\n * getStyleForProperty\n *\n * Returns the computed style property for element for .to() method.\n * Used by for the `.to()` static method.\n *\n * @param {Element} elem\n * @param {string} propertyName\n * @returns {string}\n */\nfunction getStyleForProperty(elem, propertyName) {\n  let result = defaultValues[propertyName];\n  const styleAttribute = elem.style;\n  const computedStyle = getComputedStyle(elem) || elem.currentStyle;\n  const styleValue = styleAttribute[propertyName] && !/auto|initial|none|unset/.test(styleAttribute[propertyName])\n    ? styleAttribute[propertyName]\n    : computedStyle[propertyName];\n\n  if (propertyName !== 'transform' && (propertyName in computedStyle || propertyName in styleAttribute)) {\n    result = styleValue;\n  }\n\n  return result;\n}\n\n/**\n * prepareObject\n *\n * Returns all processed valuesStart / valuesEnd.\n *\n * @param {Element} obj the values start/end object\n * @param {string} fn toggles between the two\n */\nfunction prepareObject(obj, fn) { // this, props object, type: start/end\n  const propertiesObject = fn === 'start' ? this.valuesStart : this.valuesEnd;\n\n  Object.keys(prepareProperty).forEach((component) => {\n    const prepareComponent = prepareProperty[component];\n    const supportComponent = supportedProperties[component];\n\n    Object.keys(prepareComponent).forEach((tweenCategory) => {\n      const transformObject = {};\n\n      Object.keys(obj).forEach((tweenProp) => {\n        // scroll, opacity, other components\n        if (defaultValues[tweenProp] && prepareComponent[tweenProp]) {\n          propertiesObject[tweenProp] = prepareComponent[tweenProp]\n            .call(this, tweenProp, obj[tweenProp]);\n\n        // transform\n        } else if (!defaultValues[tweenCategory] && tweenCategory === 'transform'\n          && supportComponent.includes(tweenProp)) {\n          transformObject[tweenProp] = obj[tweenProp];\n\n        // allow transformFunctions to work with preprocessed input values\n        } else if (!defaultValues[tweenProp] && tweenProp === 'transform') {\n          propertiesObject[tweenProp] = obj[tweenProp];\n\n        // colors, boxModel, category\n        } else if (!defaultValues[tweenCategory]\n          && supportComponent && supportComponent.includes(tweenProp)) {\n          propertiesObject[tweenProp] = prepareComponent[tweenCategory]\n            .call(this, tweenProp, obj[tweenProp]);\n        }\n      });\n\n      // we filter out older browsers by checking Object.keys\n      if (Object.keys(transformObject).length) {\n        propertiesObject[tweenCategory] = prepareComponent[tweenCategory]\n          .call(this, tweenCategory, transformObject);\n      }\n    });\n  });\n}\n\n/**\n * getStartValues\n *\n * Returns the start values for to() method.\n * Used by for the `.to()` static method.\n *\n * @this {KUTE.Tween} the tween instance\n */\nfunction getStartValues() {\n  const startValues = {};\n  const currentStyle = getInlineStyle(this.element);\n\n  Object.keys(this.valuesStart).forEach((tweenProp) => {\n    Object.keys(prepareStart).forEach((component) => {\n      const componentStart = prepareStart[component];\n\n      Object.keys(componentStart).forEach((tweenCategory) => {\n        // clip, opacity, scroll\n        if (tweenCategory === tweenProp && componentStart[tweenProp]) {\n          startValues[tweenProp] = componentStart[tweenCategory]\n            .call(this, tweenProp, this.valuesStart[tweenProp]);\n        // find in an array of properties\n        } else if (supportedProperties[component]\n          && supportedProperties[component].includes(tweenProp)) {\n          startValues[tweenProp] = componentStart[tweenCategory]\n            .call(this, tweenProp, this.valuesStart[tweenProp]);\n        }\n      });\n    });\n  });\n\n  // stack transformCSS props for .to() chains\n  // also add to startValues values from previous tweens\n  Object.keys(currentStyle).forEach((current) => {\n    if (!(current in this.valuesStart)) {\n      startValues[current] = currentStyle[current] || defaultValues[current];\n    }\n  });\n\n  this.valuesStart = {};\n  prepareObject.call(this, startValues, 'start');\n}\n\nvar Process = {\n  getInlineStyle,\n  getStyleForProperty,\n  getStartValues,\n  prepareObject,\n};\n\nconst connect = {};\n/** @type {KUTE.TweenBase | KUTE.Tween | KUTE.TweenExtra} */\nconnect.tween = null;\nconnect.processEasing = null;\n\nconst Easing = {\n  linear: new CubicBezier(0, 0, 1, 1, 'linear'),\n  easingSinusoidalIn: new CubicBezier(0.47, 0, 0.745, 0.715, 'easingSinusoidalIn'),\n  easingSinusoidalOut: new CubicBezier(0.39, 0.575, 0.565, 1, 'easingSinusoidalOut'),\n  easingSinusoidalInOut: new CubicBezier(0.445, 0.05, 0.55, 0.95, 'easingSinusoidalInOut'),\n\n  easingQuadraticIn: new CubicBezier(0.550, 0.085, 0.680, 0.530, 'easingQuadraticIn'),\n  easingQuadraticOut: new CubicBezier(0.250, 0.460, 0.450, 0.940, 'easingQuadraticOut'),\n  easingQuadraticInOut: new CubicBezier(0.455, 0.030, 0.515, 0.955, 'easingQuadraticInOut'),\n\n  easingCubicIn: new CubicBezier(0.55, 0.055, 0.675, 0.19, 'easingCubicIn'),\n  easingCubicOut: new CubicBezier(0.215, 0.61, 0.355, 1, 'easingCubicOut'),\n  easingCubicInOut: new CubicBezier(0.645, 0.045, 0.355, 1, 'easingCubicInOut'),\n\n  easingQuarticIn: new CubicBezier(0.895, 0.03, 0.685, 0.22, 'easingQuarticIn'),\n  easingQuarticOut: new CubicBezier(0.165, 0.84, 0.44, 1, 'easingQuarticOut'),\n  easingQuarticInOut: new CubicBezier(0.77, 0, 0.175, 1, 'easingQuarticInOut'),\n\n  easingQuinticIn: new CubicBezier(0.755, 0.05, 0.855, 0.06, 'easingQuinticIn'),\n  easingQuinticOut: new CubicBezier(0.23, 1, 0.32, 1, 'easingQuinticOut'),\n  easingQuinticInOut: new CubicBezier(0.86, 0, 0.07, 1, 'easingQuinticInOut'),\n\n  easingExponentialIn: new CubicBezier(0.95, 0.05, 0.795, 0.035, 'easingExponentialIn'),\n  easingExponentialOut: new CubicBezier(0.19, 1, 0.22, 1, 'easingExponentialOut'),\n  easingExponentialInOut: new CubicBezier(1, 0, 0, 1, 'easingExponentialInOut'),\n\n  easingCircularIn: new CubicBezier(0.6, 0.04, 0.98, 0.335, 'easingCircularIn'),\n  easingCircularOut: new CubicBezier(0.075, 0.82, 0.165, 1, 'easingCircularOut'),\n  easingCircularInOut: new CubicBezier(0.785, 0.135, 0.15, 0.86, 'easingCircularInOut'),\n\n  easingBackIn: new CubicBezier(0.6, -0.28, 0.735, 0.045, 'easingBackIn'),\n  easingBackOut: new CubicBezier(0.175, 0.885, 0.32, 1.275, 'easingBackOut'),\n  easingBackInOut: new CubicBezier(0.68, -0.55, 0.265, 1.55, 'easingBackInOut'),\n};\n\n/**\n * Returns a valid `easingFunction`.\n *\n * @param {KUTE.easingFunction | string} fn function name or constructor name\n * @returns {KUTE.easingFunction} a valid easingfunction\n */\nfunction processBezierEasing(fn) {\n  if (typeof fn === 'function') {\n    return fn;\n  } if (typeof (Easing[fn]) === 'function') {\n    return Easing[fn];\n  } if (/bezier/.test(fn)) {\n    const bz = fn.replace(/bezier|\\s|\\(|\\)/g, '').split(',');\n    return new CubicBezier(bz[0] * 1, bz[1] * 1, bz[2] * 1, bz[3] * 1); // bezier easing\n  }\n  // if (/elastic|bounce/i.test(fn)) {\n  //   throw TypeError(`KUTE - CubicBezier doesn't support ${fn} easing.`);\n  // }\n  return Easing.linear;\n}\n\nconnect.processEasing = processBezierEasing;\n\n/**\n * selector\n *\n * A selector utility for KUTE.js.\n *\n * @param {KUTE.selectorType} el target(s) or string selector\n * @param {boolean | number} multi when true returns an array/collection of elements\n * @returns {Element | Element[] | null}\n */\nfunction selector(el, multi) {\n  try {\n    let requestedElem;\n    let itemsArray;\n    if (multi) {\n      itemsArray = el instanceof Array && el.every((x) => x instanceof Element);\n      requestedElem = el instanceof HTMLCollection || el instanceof NodeList || itemsArray\n        ? el : document.querySelectorAll(el);\n    } else {\n      requestedElem = el instanceof Element || el === window // scroll\n        ? el : document.querySelector(el);\n    }\n    return requestedElem;\n  } catch (e) {\n    throw TypeError(`KUTE.js - Element(s) not found: ${el}.`);\n  }\n}\n\nfunction queueStart() {\n  // fire onStart actions\n  Object.keys(onStart).forEach((obj) => {\n    if (typeof (onStart[obj]) === 'function') {\n      onStart[obj].call(this, obj); // easing functions\n    } else {\n      Object.keys(onStart[obj]).forEach((prop) => {\n        onStart[obj][prop].call(this, prop);\n      });\n    }\n  });\n\n  // add interpolations\n  linkInterpolation.call(this);\n}\n\n/**\n * The `TweenBase` constructor creates a new `Tween` object\n * for a single `HTMLElement` and returns it.\n *\n * `TweenBase` is meant to be used with pre-processed values.\n */\nclass TweenBase {\n  /**\n   * @param {Element} targetElement the target element\n   * @param {KUTE.tweenProps} startObject the start values\n   * @param {KUTE.tweenProps} endObject the end values\n   * @param {KUTE.tweenOptions} opsObject the end values\n   * @returns {TweenBase} the resulting Tween object\n   */\n  constructor(targetElement, startObject, endObject, opsObject) {\n    // element animation is applied to\n    this.element = targetElement;\n\n    /** @type {boolean} */\n    this.playing = false;\n    /** @type {number?} */\n    this._startTime = null;\n    /** @type {boolean} */\n    this._startFired = false;\n\n    // type is set via KUTE.tweenProps\n    this.valuesEnd = endObject;\n    this.valuesStart = startObject;\n\n    // OPTIONS\n    const options = opsObject || {};\n    // internal option to process inline/computed style at start instead of init\n    // used by to() method and expects object : {} / false\n    this._resetStart = options.resetStart || 0;\n    // you can only set a core easing function as default\n    /** @type {KUTE.easingOption} */\n    this._easing = typeof (options.easing) === 'function' ? options.easing : connect.processEasing(options.easing);\n    /** @type {number} */\n    this._duration = options.duration || defaultOptions$1.duration; // duration option | default\n    /** @type {number} */\n    this._delay = options.delay || defaultOptions$1.delay; // delay option | default\n\n    // set other options\n    Object.keys(options).forEach((op) => {\n      const internalOption = `_${op}`;\n      if (!(internalOption in this)) this[internalOption] = options[op];\n    });\n\n    // callbacks should not be set as undefined\n    // this._onStart = options.onStart\n    // this._onUpdate = options.onUpdate\n    // this._onStop = options.onStop\n    // this._onComplete = options.onComplete\n\n    // queue the easing\n    const easingFnName = this._easing.name;\n    if (!onStart[easingFnName]) {\n      onStart[easingFnName] = function easingFn(prop) {\n        if (!KEC[prop] && prop === this._easing.name) KEC[prop] = this._easing;\n      };\n    }\n\n    return this;\n  }\n\n  /**\n   * Starts tweening\n   * @param {number?} time the tween start time\n   * @returns {TweenBase} this instance\n   */\n  start(time) {\n    // now it's a good time to start\n    add(this);\n    this.playing = true;\n\n    this._startTime = typeof time !== 'undefined' ? time : KEC.Time();\n    this._startTime += this._delay;\n\n    if (!this._startFired) {\n      if (this._onStart) {\n        this._onStart.call(this);\n      }\n\n      queueStart.call(this);\n\n      this._startFired = true;\n    }\n\n    if (!Tick) Ticker();\n    return this;\n  }\n\n  /**\n   * Stops tweening\n   * @returns {TweenBase} this instance\n   */\n  stop() {\n    if (this.playing) {\n      remove(this);\n      this.playing = false;\n\n      if (this._onStop) {\n        this._onStop.call(this);\n      }\n      this.close();\n    }\n    return this;\n  }\n\n  /**\n   * Trigger internal completion callbacks.\n   */\n  close() {\n    // scroll|transformMatrix need this\n    Object.keys(onComplete).forEach((component) => {\n      Object.keys(onComplete[component]).forEach((toClose) => {\n        onComplete[component][toClose].call(this, toClose);\n      });\n    });\n    // when all animations are finished, stop ticking after ~3 frames\n    this._startFired = false;\n    stop.call(this);\n  }\n\n  /**\n   * Schedule another tween instance to start once this one completes.\n   * @param {KUTE.chainOption} args the tween animation start time\n   * @returns {TweenBase} this instance\n   */\n  chain(args) {\n    this._chain = [];\n    this._chain = args.length ? args : this._chain.concat(args);\n    return this;\n  }\n\n  /**\n   * Stop tweening the chained tween instances.\n   */\n  stopChainedTweens() {\n    if (this._chain && this._chain.length) this._chain.forEach((tw) => tw.stop());\n  }\n\n  /**\n   * Update the tween on each tick.\n   * @param {number} time the tick time\n   * @returns {boolean} this instance\n   */\n  update(time) {\n    const T = time !== undefined ? time : KEC.Time();\n\n    let elapsed;\n\n    if (T < this._startTime && this.playing) { return true; }\n\n    elapsed = (T - this._startTime) / this._duration;\n    elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;\n\n    // calculate progress\n    const progress = this._easing(elapsed);\n\n    // render the update\n    Object.keys(this.valuesEnd).forEach((tweenProp) => {\n      KEC[tweenProp](this.element,\n        this.valuesStart[tweenProp],\n        this.valuesEnd[tweenProp],\n        progress);\n    });\n\n    // fire the updateCallback\n    if (this._onUpdate) {\n      this._onUpdate.call(this);\n    }\n\n    if (elapsed === 1) {\n      // fire the complete callback\n      if (this._onComplete) {\n        this._onComplete.call(this);\n      }\n\n      // now we're sure no animation is running\n      this.playing = false;\n\n      // stop ticking when finished\n      this.close();\n\n      // start animating chained tweens\n      if (this._chain !== undefined && this._chain.length) {\n        this._chain.map((tw) => tw.start());\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n}\n\n// Update Tween Interface\nconnect.tween = TweenBase;\n\n/**\n * The `KUTE.Tween()` constructor creates a new `Tween` object\n * for a single `HTMLElement` and returns it.\n *\n * This constructor adds additional functionality and is the default\n * Tween object constructor in KUTE.js.\n */\nclass Tween extends TweenBase {\n  /**\n   * @param {KUTE.tweenParams} args (*target*, *startValues*, *endValues*, *options*)\n   * @returns {Tween} the resulting Tween object\n   */\n  constructor(...args) {\n    super(...args); // this calls the constructor of TweenBase\n\n    // reset interpolation values\n    this.valuesStart = {};\n    this.valuesEnd = {};\n\n    // const startObject = args[1];\n    // const endObject = args[2];\n    const [startObject, endObject, options] = args.slice(1);\n\n    // set valuesEnd\n    prepareObject.call(this, endObject, 'end');\n\n    // set valuesStart\n    if (this._resetStart) {\n      this.valuesStart = startObject;\n    } else {\n      prepareObject.call(this, startObject, 'start');\n    }\n\n    // ready for crossCheck\n    if (!this._resetStart) {\n      Object.keys(crossCheck).forEach((component) => {\n        Object.keys(crossCheck[component]).forEach((checkProp) => {\n          crossCheck[component][checkProp].call(this, checkProp);\n        });\n      });\n    }\n\n    // set paused state\n    /** @type {boolean} */\n    this.paused = false;\n    /** @type {number?} */\n    this._pauseTime = null;\n\n    // additional properties and options\n    /** @type {number?} */\n    this._repeat = options.repeat || defaultOptions$1.repeat;\n    /** @type {number?} */\n    this._repeatDelay = options.repeatDelay || defaultOptions$1.repeatDelay;\n    // we cache the number of repeats to be able to put it back after all cycles finish\n    /** @type {number?} */\n    this._repeatOption = this._repeat;\n\n    // yoyo needs at least repeat: 1\n    /** @type {KUTE.tweenProps} */\n    this.valuesRepeat = {}; // valuesRepeat\n    /** @type {boolean} */\n    this._yoyo = options.yoyo || defaultOptions$1.yoyo;\n    /** @type {boolean} */\n    this._reversed = false;\n\n    // don't load extra callbacks\n    // this._onPause = options.onPause || defaultOptions.onPause\n    // this._onResume = options.onResume || defaultOptions.onResume\n\n    // chained Tweens\n    // this._chain = options.chain || defaultOptions.chain;\n    return this;\n  }\n\n  /**\n   * Starts tweening, extended method\n   * @param {number?} time the tween start time\n   * @returns {Tween} this instance\n   */\n  start(time) {\n    // on start we reprocess the valuesStart for TO() method\n    if (this._resetStart) {\n      this.valuesStart = this._resetStart;\n      getStartValues.call(this);\n\n      // this is where we do the valuesStart and valuesEnd check for fromTo() method\n      Object.keys(crossCheck).forEach((component) => {\n        Object.keys(crossCheck[component]).forEach((checkProp) => {\n          crossCheck[component][checkProp].call(this, checkProp);\n        });\n      });\n    }\n    // still not paused\n    this.paused = false;\n\n    // set yoyo values\n    if (this._yoyo) {\n      Object.keys(this.valuesEnd).forEach((endProp) => {\n        this.valuesRepeat[endProp] = this.valuesStart[endProp];\n      });\n    }\n\n    super.start(time);\n\n    return this;\n  }\n\n  /**\n   * Stops tweening, extended method\n   * @returns {Tween} this instance\n   */\n  stop() {\n    super.stop();\n    if (!this.paused && this.playing) {\n      this.paused = false;\n      this.stopChainedTweens();\n    }\n    return this;\n  }\n\n  /**\n   * Trigger internal completion callbacks.\n   */\n  close() {\n    super.close();\n\n    if (this._repeatOption > 0) {\n      this._repeat = this._repeatOption;\n    }\n    if (this._yoyo && this._reversed === true) {\n      this.reverse();\n      this._reversed = false;\n    }\n\n    return this;\n  }\n\n  /**\n   * Resume tweening\n   * @returns {Tween} this instance\n   */\n  resume() {\n    if (this.paused && this.playing) {\n      this.paused = false;\n      if (this._onResume !== undefined) {\n        this._onResume.call(this);\n      }\n      // re-queue execution context\n      queueStart.call(this);\n      // update time and let it roll\n      this._startTime += KEC.Time() - this._pauseTime;\n      add(this);\n      // restart ticker if stopped\n      if (!Tick) Ticker();\n    }\n    return this;\n  }\n\n  /**\n   * Pause tweening\n   * @returns {Tween} this instance\n   */\n  pause() {\n    if (!this.paused && this.playing) {\n      remove(this);\n      this.paused = true;\n      this._pauseTime = KEC.Time();\n      if (this._onPause !== undefined) {\n        this._onPause.call(this);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Reverses start values with end values\n   */\n  reverse() {\n    Object.keys(this.valuesEnd).forEach((reverseProp) => {\n      const tmp = this.valuesRepeat[reverseProp];\n      this.valuesRepeat[reverseProp] = this.valuesEnd[reverseProp];\n      this.valuesEnd[reverseProp] = tmp;\n      this.valuesStart[reverseProp] = this.valuesRepeat[reverseProp];\n    });\n  }\n\n  /**\n   * Update the tween on each tick.\n   * @param {number} time the tick time\n   * @returns {boolean} this instance\n   */\n  update(time) {\n    const T = time !== undefined ? time : KEC.Time();\n\n    let elapsed;\n\n    if (T < this._startTime && this.playing) { return true; }\n\n    elapsed = (T - this._startTime) / this._duration;\n    elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;\n\n    // calculate progress\n    const progress = this._easing(elapsed);\n\n    // render the update\n    Object.keys(this.valuesEnd).forEach((tweenProp) => {\n      KEC[tweenProp](this.element,\n        this.valuesStart[tweenProp],\n        this.valuesEnd[tweenProp],\n        progress);\n    });\n\n    // fire the updateCallback\n    if (this._onUpdate) {\n      this._onUpdate.call(this);\n    }\n\n    if (elapsed === 1) {\n      if (this._repeat > 0) {\n        if (Number.isFinite(this._repeat)) this._repeat -= 1;\n\n        // set the right time for delay\n        this._startTime = T;\n        if (Number.isFinite(this._repeat) && this._yoyo && !this._reversed) {\n          this._startTime += this._repeatDelay;\n        }\n\n        if (this._yoyo) { // handle yoyo\n          this._reversed = !this._reversed;\n          this.reverse();\n        }\n\n        return true;\n      }\n\n      // fire the complete callback\n      if (this._onComplete) {\n        this._onComplete.call(this);\n      }\n\n      // now we're sure no animation is running\n      this.playing = false;\n\n      // stop ticking when finished\n      this.close();\n\n      // start animating chained tweens\n      if (this._chain !== undefined && this._chain.length) {\n        this._chain.forEach((tw) => tw.start());\n      }\n\n      return false;\n    }\n    return true;\n  }\n}\n\n// Update Tween Interface Update\nconnect.tween = Tween;\n\n/**\n * The static method creates a new `Tween` object for each `HTMLElement`\n * from and `Array`, `HTMLCollection` or `NodeList`.\n */\nclass TweenCollection {\n  /**\n   *\n   * @param {Element[] | HTMLCollection | NodeList} els target elements\n   * @param {KUTE.tweenProps} vS the start values\n   * @param {KUTE.tweenProps} vE the end values\n   * @param {KUTE.tweenOptions} Options tween options\n   * @returns {TweenCollection} the Tween object collection\n   */\n  constructor(els, vS, vE, Options) {\n    const TweenConstructor = connect.tween;\n    /** @type {KUTE.twCollection[]} */\n    this.tweens = [];\n\n    const Ops = Options || {};\n    /** @type {number?} */\n    Ops.delay = Ops.delay || defaultOptions$1.delay;\n\n    // set all options\n    const options = [];\n\n    Array.from(els).forEach((el, i) => {\n      options[i] = Ops || {};\n      options[i].delay = i > 0 ? Ops.delay + (Ops.offset || defaultOptions$1.offset) : Ops.delay;\n      if (el instanceof Element) {\n        this.tweens.push(new TweenConstructor(el, vS, vE, options[i]));\n      } else {\n        throw Error(`KUTE - ${el} is not instanceof Element`);\n      }\n    });\n\n    /** @type {number?} */\n    this.length = this.tweens.length;\n    return this;\n  }\n\n  /**\n   * Starts tweening, all targets\n   * @param {number?} time the tween start time\n   * @returns {TweenCollection} this instance\n   */\n  start(time) {\n    const T = time === undefined ? KEC.Time() : time;\n    this.tweens.map((tween) => tween.start(T));\n    return this;\n  }\n\n  /**\n   * Stops tweening, all targets and their chains\n   * @returns {TweenCollection} this instance\n   */\n  stop() {\n    this.tweens.map((tween) => tween.stop());\n    return this;\n  }\n\n  /**\n   * Pause tweening, all targets\n   * @returns {TweenCollection} this instance\n   */\n  pause() {\n    this.tweens.map((tween) => tween.pause());\n    return this;\n  }\n\n  /**\n   * Resume tweening, all targets\n   * @returns {TweenCollection} this instance\n   */\n  resume() {\n    this.tweens.map((tween) => tween.resume());\n    return this;\n  }\n\n  /**\n   * Schedule another tween or collection to start after\n   * this one is complete.\n   * @param {number?} args the tween start time\n   * @returns {TweenCollection} this instance\n   */\n  chain(args) {\n    const lastTween = this.tweens[this.length - 1];\n    if (args instanceof TweenCollection) {\n      lastTween.chain(args.tweens);\n    } else if (args instanceof connect.tween) {\n      lastTween.chain(args);\n    } else {\n      throw new TypeError('KUTE.js - invalid chain value');\n    }\n    return this;\n  }\n\n  /**\n   * Check if any tween instance is playing\n   * @param {number?} time the tween start time\n   * @returns {TweenCollection} this instance\n   */\n  playing() {\n    return this.tweens.some((tw) => tw.playing);\n  }\n\n  /**\n   * Remove all tweens in the collection\n   */\n  removeTweens() {\n    this.tweens = [];\n  }\n\n  /**\n   * Returns the maximum animation duration\n   * @returns {number} this instance\n   */\n  getMaxDuration() {\n    const durations = [];\n    this.tweens.forEach((tw) => {\n      durations.push(tw._duration + tw._delay + tw._repeat * tw._repeatDelay);\n    });\n    return Math.max(durations);\n  }\n}\n\nconst { tween: TweenConstructor$1 } = connect;\n\n/**\n * The `KUTE.to()` static method returns a new Tween object\n * for a single `HTMLElement` at its current state.\n *\n * @param {Element} element target element\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenOptions} optionsObj tween options\n * @returns {KUTE.Tween} the resulting Tween object\n */\nfunction to(element, endObject, optionsObj) {\n  const options = optionsObj || {};\n  options.resetStart = endObject;\n  return new TweenConstructor$1(selector(element), endObject, endObject, options);\n}\n\nconst { tween: TweenConstructor } = connect;\n\n/**\n * The `KUTE.fromTo()` static method returns a new Tween object\n * for a single `HTMLElement` at a given state.\n *\n * @param {Element} element target element\n * @param {KUTE.tweenProps} startObject\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenOptions} optionsObj tween options\n * @returns {KUTE.Tween} the resulting Tween object\n */\nfunction fromTo(element, startObject, endObject, optionsObj) {\n  const options = optionsObj || {};\n  return new TweenConstructor(selector(element), startObject, endObject, options);\n}\n\n/**\n * The `KUTE.allTo()` static method creates a new Tween object\n * for multiple `HTMLElement`s, `HTMLCollection` or `NodeListat`\n * at their current state.\n *\n * @param {Element[] | HTMLCollection | NodeList} elements target elements\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenProps} optionsObj progress\n * @returns {TweenCollection} the Tween object collection\n */\nfunction allTo(elements, endObject, optionsObj) {\n  const options = optionsObj || {};\n  options.resetStart = endObject;\n  return new TweenCollection(selector(elements, true), endObject, endObject, options);\n}\n\n/**\n * The `KUTE.allFromTo()` static method creates a new Tween object\n * for multiple `HTMLElement`s, `HTMLCollection` or `NodeListat`\n * at a given state.\n *\n * @param {Element[] | HTMLCollection | NodeList} elements target elements\n * @param {KUTE.tweenProps} startObject\n * @param {KUTE.tweenProps} endObject\n * @param {KUTE.tweenOptions} optionsObj tween options\n * @returns {TweenCollection} the Tween object collection\n */\nfunction allFromTo(elements, startObject, endObject, optionsObj) {\n  const options = optionsObj || {};\n  return new TweenCollection(selector(elements, true), startObject, endObject, options);\n}\n\n/**\n * Animation Class\n *\n * Registers components by populating KUTE.js objects and makes sure\n * no duplicate component / property is allowed.\n */\nclass Animation {\n  /**\n   * @constructor\n   * @param {KUTE.fullComponent} Component\n   */\n  constructor(Component) {\n    try {\n      if (Component.component in supportedProperties) {\n        throw Error(`KUTE - ${Component.component} already registered`);\n      } else if (Component.property in defaultValues) {\n        throw Error(`KUTE - ${Component.property} already registered`);\n      }\n    } catch (e) {\n      throw Error(e);\n    }\n\n    const propertyInfo = this;\n    const ComponentName = Component.component;\n    // const Objects = { defaultValues, defaultOptions, Interpolate, linkProperty, Util }\n    const Functions = {\n      prepareProperty, prepareStart, onStart, onComplete, crossCheck,\n    };\n    const Category = Component.category;\n    const Property = Component.property;\n    const Length = (Component.properties && Component.properties.length)\n      || (Component.subProperties && Component.subProperties.length);\n\n    // single property\n    // {property,defaultvalue,defaultOptions,Interpolate,functions}\n\n    // category colors, boxModel, borderRadius\n    // {category,properties,defaultvalues,defaultOptions,Interpolate,functions}\n\n    // property with multiple sub properties. Eg transform, filter\n    // {property,subProperties,defaultvalues,defaultOptions,Interpolate,functions}\n\n    // property with multiple sub properties. Eg htmlAttributes\n    // {category,subProperties,defaultvalues,defaultOptions,Interpolate,functions}\n\n    // set supported category/property\n    supportedProperties[ComponentName] = Component.properties\n      || Component.subProperties || Component.property;\n\n    // set defaultValues\n    if ('defaultValue' in Component) { // value 0 will invalidate\n      defaultValues[Property] = Component.defaultValue;\n\n      // minimal info\n      propertyInfo.supports = `${Property} property`;\n    } else if (Component.defaultValues) {\n      Object.keys(Component.defaultValues).forEach((dv) => {\n        defaultValues[dv] = Component.defaultValues[dv];\n      });\n\n      // minimal info\n      propertyInfo.supports = `${Length || Property} ${Property || Category} properties`;\n    }\n\n    // set additional options\n    if (Component.defaultOptions) {\n      // Object.keys(Component.defaultOptions).forEach((op) => {\n      //   defaultOptions[op] = Component.defaultOptions[op];\n      // });\n      Object.assign(defaultOptions$1, Component.defaultOptions);\n    }\n\n    // set functions\n    if (Component.functions) {\n      Object.keys(Functions).forEach((fn) => {\n        if (fn in Component.functions) {\n          if (typeof (Component.functions[fn]) === 'function') {\n            // if (!Functions[fn][ Category||Property ]) {\n            //   Functions[fn][ Category||Property ] = Component.functions[fn];\n            // }\n            if (!Functions[fn][ComponentName]) Functions[fn][ComponentName] = {};\n            if (!Functions[fn][ComponentName][Category || Property]) {\n              Functions[fn][ComponentName][Category || Property] = Component.functions[fn];\n            }\n          } else {\n            Object.keys(Component.functions[fn]).forEach((ofn) => {\n              // !Functions[fn][ofn] && (Functions[fn][ofn] = Component.functions[fn][ofn])\n              if (!Functions[fn][ComponentName]) Functions[fn][ComponentName] = {};\n              if (!Functions[fn][ComponentName][ofn]) {\n                Functions[fn][ComponentName][ofn] = Component.functions[fn][ofn];\n              }\n            });\n          }\n        }\n      });\n    }\n\n    // set component interpolation functions\n    if (Component.Interpolate) {\n      Object.keys(Component.Interpolate).forEach((fni) => {\n        const compIntObj = Component.Interpolate[fni];\n        if (typeof (compIntObj) === 'function' && !interpolate[fni]) {\n          interpolate[fni] = compIntObj;\n        } else {\n          Object.keys(compIntObj).forEach((sfn) => {\n            if (typeof (compIntObj[sfn]) === 'function' && !interpolate[fni]) {\n              interpolate[fni] = compIntObj[sfn];\n            }\n          });\n        }\n      });\n\n      linkProperty[ComponentName] = Component.Interpolate;\n    }\n\n    // set component util\n    if (Component.Util) {\n      Object.keys(Component.Util).forEach((fnu) => {\n        if (!Util[fnu]) Util[fnu] = Component.Util[fnu];\n      });\n    }\n\n    return propertyInfo;\n  }\n}\n\n/**\n * trueDimension\n *\n * Returns the string value of a specific CSS property converted into a nice\n * { v = value, u = unit } object.\n *\n * @param {string} dimValue the property string value\n * @param {boolean | number} isAngle sets the utility to investigate angles\n * @returns {{v: number, u: string}} the true {value, unit} tuple\n */\nconst trueDimension = (dimValue, isAngle) => {\n  const intValue = parseInt(dimValue, 10) || 0;\n  const mUnits = ['px', '%', 'deg', 'rad', 'em', 'rem', 'vh', 'vw'];\n  let theUnit;\n\n  for (let mIndex = 0; mIndex < mUnits.length; mIndex += 1) {\n    if (typeof dimValue === 'string' && dimValue.includes(mUnits[mIndex])) {\n      theUnit = mUnits[mIndex]; break;\n    }\n  }\n  if (theUnit === undefined) {\n    theUnit = isAngle ? 'deg' : 'px';\n  }\n\n  return { v: intValue, u: theUnit };\n};\n\n/**\n * Numbers Interpolation Function.\n *\n * @param {number} a start value\n * @param {number} b end value\n * @param {number} v progress\n * @returns {number} the interpolated number\n */\nfunction numbers(a, b, v) {\n  const A = +a;\n  const B = b - a;\n  // a = +a; b -= a;\n  return A + B * v;\n}\n\n// Component Functions\n/**\n * Sets the update function for the property.\n * @param {string} tweenProp the property name\n */\nfunction boxModelOnStart(tweenProp) {\n  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      /* eslint-disable no-param-reassign -- impossible to satisfy */\n      /* eslint-disable no-bitwise -- impossible to satisfy */\n      elem.style[tweenProp] = `${v > 0.99 || v < 0.01\n        ? ((numbers(a, b, v) * 10) >> 0) / 10\n        : (numbers(a, b, v)) >> 0}px`;\n      /* eslint-enable no-bitwise */\n      /* eslint-enable no-param-reassign */\n    };\n  }\n}\n\n// Component Functions\n/**\n * Returns the current property computed style.\n * @param {string} tweenProp the property name\n * @returns {string} computed style for property\n */\nfunction getBoxModel(tweenProp) {\n  return getStyleForProperty(this.element, tweenProp) || defaultValues[tweenProp];\n}\n\n/**\n * Returns the property tween object.\n * @param {string} tweenProp the property name\n * @param {string} value the property name\n * @returns {number} the property tween object\n */\nfunction prepareBoxModel(tweenProp, value) {\n  const boxValue = trueDimension(value);\n  const offsetProp = tweenProp === 'height' ? 'offsetHeight' : 'offsetWidth';\n  return boxValue.u === '%' ? (boxValue.v * this.element[offsetProp]) / 100 : boxValue.v;\n}\n\n// Component Base Props\nconst essentialBoxProps = ['top', 'left', 'width', 'height'];\nconst essentialBoxPropsValues = {\n  top: 0, left: 0, width: 0, height: 0,\n};\n\nconst essentialBoxOnStart = {};\nessentialBoxProps.forEach((x) => { essentialBoxOnStart[x] = boxModelOnStart; });\n\n// All Component Functions\nconst essentialBoxModelFunctions = {\n  prepareStart: getBoxModel,\n  prepareProperty: prepareBoxModel,\n  onStart: essentialBoxOnStart,\n};\n\n// Component Essential\nconst BoxModelEssential = {\n  component: 'essentialBoxModel',\n  category: 'boxModel',\n  properties: essentialBoxProps,\n  defaultValues: essentialBoxPropsValues,\n  Interpolate: { numbers },\n  functions: essentialBoxModelFunctions,\n  Util: { trueDimension },\n};\n\n/**\n * hexToRGB\n *\n * Converts a #HEX color format into RGB\n * and returns a color object {r,g,b}.\n *\n * @param {string} hex the degree angle\n * @returns {KUTE.colorObject | null} the radian angle\n */\nconst hexToRGB = (hex) => {\n  // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n  const hexShorthand = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  const HEX = hex.replace(hexShorthand, (_, r, g, b) => r + r + g + g + b + b);\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(HEX);\n\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16),\n  } : null;\n};\n\n/**\n * trueColor\n *\n * Transform any color to rgba()/rgb() and return a nice RGB(a) object.\n *\n * @param {string} colorString the color input\n * @returns {KUTE.colorObject} the {r,g,b,a} color object\n */\nconst trueColor = (colorString) => {\n  let result;\n  if (/rgb|rgba/.test(colorString)) { // first check if it's a rgb string\n    const vrgb = colorString.replace(/\\s|\\)/, '').split('(')[1].split(',');\n    const colorAlpha = vrgb[3] ? vrgb[3] : null;\n    if (!colorAlpha) {\n      result = { r: parseInt(vrgb[0], 10), g: parseInt(vrgb[1], 10), b: parseInt(vrgb[2], 10) };\n    } else {\n      result = {\n        r: parseInt(vrgb[0], 10),\n        g: parseInt(vrgb[1], 10),\n        b: parseInt(vrgb[2], 10),\n        a: parseFloat(colorAlpha),\n      };\n    }\n  } if (/^#/.test(colorString)) {\n    const fromHex = hexToRGB(colorString);\n    result = { r: fromHex.r, g: fromHex.g, b: fromHex.b };\n  } if (/transparent|none|initial|inherit/.test(colorString)) {\n    result = {\n      r: 0, g: 0, b: 0, a: 0,\n    };\n  }\n  // maybe we can check for web safe colors\n  // only works in a browser\n  if (!/^#|^rgb/.test(colorString)) {\n    const siteHead = document.getElementsByTagName('head')[0];\n    siteHead.style.color = colorString;\n    let webColor = getComputedStyle(siteHead, null).color;\n    webColor = /rgb/.test(webColor) ? webColor.replace(/[^\\d,]/g, '').split(',') : [0, 0, 0];\n    siteHead.style.color = '';\n    result = {\n      r: parseInt(webColor[0], 10),\n      g: parseInt(webColor[1], 10),\n      b: parseInt(webColor[2], 10),\n    };\n  }\n  return result;\n};\n\n/**\n * Color Interpolation Function.\n *\n * @param {KUTE.colorObject} a start color\n * @param {KUTE.colorObject} b end color\n * @param {number} v progress\n * @returns {string} the resulting color\n */\nfunction colors(a, b, v) {\n  const _c = {};\n  const ep = ')';\n  const cm = ',';\n  const rgb = 'rgb(';\n  const rgba = 'rgba(';\n\n  Object.keys(b).forEach((c) => {\n    if (c !== 'a') {\n      _c[c] = numbers(a[c], b[c], v) >> 0 || 0; // eslint-disable-line no-bitwise\n    } else if (a[c] && b[c]) {\n      _c[c] = (numbers(a[c], b[c], v) * 100 >> 0) / 100; // eslint-disable-line no-bitwise\n    }\n  });\n\n  return !_c.a\n    ? rgb + _c.r + cm + _c.g + cm + _c.b + ep\n    : rgba + _c.r + cm + _c.g + cm + _c.b + cm + _c.a + ep;\n}\n\n// Component Functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartColors(tweenProp) {\n  if (this.valuesEnd[tweenProp] && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      // eslint-disable-next-line no-param-reassign\n      elem.style[tweenProp] = colors(a, b, v);\n    };\n  }\n}\n\n// Component Properties\n// supported formats\n// 'hex', 'rgb', 'rgba' '#fff' 'rgb(0,0,0)' / 'rgba(0,0,0,0)' 'red' (IE9+)\nconst supportedColors = [\n  'color', 'backgroundColor', 'outlineColor',\n  'borderColor', 'borderTopColor', 'borderRightColor',\n  'borderBottomColor', 'borderLeftColor',\n];\n\nconst defaultColors = {};\nsupportedColors.forEach((tweenProp) => {\n  defaultColors[tweenProp] = '#000';\n});\n\n// Component Functions\nconst colorsOnStart = {};\nsupportedColors.forEach((x) => {\n  colorsOnStart[x] = onStartColors;\n});\n\n/**\n * Returns the current property computed style.\n * @param {string} prop the property name\n * @returns {string} property computed style\n */\nfunction getColor(prop/* , value */) {\n  return getStyleForProperty(this.element, prop) || defaultValues[prop];\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string} value the property value\n * @returns {KUTE.colorObject} the property tween object\n */\nfunction prepareColor(/* prop, */_, value) {\n  return trueColor(value);\n}\n\n// All Component Functions\nconst colorFunctions = {\n  prepareStart: getColor,\n  prepareProperty: prepareColor,\n  onStart: colorsOnStart,\n};\n\n// Component Full\nconst colorProperties = {\n  component: 'colorProperties',\n  category: 'colors',\n  properties: supportedColors,\n  defaultValues: defaultColors,\n  Interpolate: { numbers, colors },\n  functions: colorFunctions,\n  Util: { trueColor },\n};\n\n// Component Special\nconst attributes = {};\n\nconst onStartAttr = {\n  /**\n   * onStartAttr.attr\n   *\n   * Sets the sub-property update function.\n   * @param {string} tweenProp the property name\n   */\n  attr(tweenProp) {\n    if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n      KEC[tweenProp] = (elem, vS, vE, v) => {\n        Object.keys(vE).forEach((oneAttr) => {\n          KEC.attributes[oneAttr](elem, oneAttr, vS[oneAttr], vE[oneAttr], v);\n        });\n      };\n    }\n  },\n  /**\n   * onStartAttr.attributes\n   *\n   * Sets the update function for the property.\n   * @param {string} tweenProp the property name\n   */\n  attributes(tweenProp) {\n    if (!KEC[tweenProp] && this.valuesEnd.attr) {\n      KEC[tweenProp] = attributes;\n    }\n  },\n};\n\n// Component Name\nconst ComponentName = 'htmlAttributes';\n\n// Component Properties\nconst svgColors = ['fill', 'stroke', 'stop-color'];\n\n// Component Util\n/**\n * Returns non-camelcase property name.\n * @param {string} a the camelcase property name\n * @returns {string} the non-camelcase property name\n */\nfunction replaceUppercase(a) { return a.replace(/[A-Z]/g, '-$&').toLowerCase(); }\n\n// Component Functions\n/**\n * Returns the current attribute value.\n * @param {string} _ the property name\n * @param {string} value the property value\n * @returns {{[x:string]: string}} attribute value\n */\nfunction getAttr(/* tweenProp, */_, value) {\n  const attrStartValues = {};\n  Object.keys(value).forEach((attr) => {\n    // get the value for 'fill-opacity' not fillOpacity\n    // also 'width' not the internal 'width_px'\n    const attribute = replaceUppercase(attr).replace(/_+[a-z]+/, '');\n    const currentValue = this.element.getAttribute(attribute);\n    attrStartValues[attribute] = svgColors.includes(attribute)\n      ? (currentValue || 'rgba(0,0,0,0)')\n      : (currentValue || (/opacity/i.test(attr) ? 1 : 0));\n  });\n\n  return attrStartValues;\n}\n\n/**\n * Returns the property tween object.\n * @param {string} tweenProp the property name\n * @param {string} attrObj the property value\n * @returns {number} the property tween object\n */\nfunction prepareAttr(tweenProp, attrObj) { // attr (string),attrObj (object)\n  const attributesObject = {};\n\n  Object.keys(attrObj).forEach((p) => {\n    const prop = replaceUppercase(p);\n    const regex = /(%|[a-z]+)$/;\n    const currentValue = this.element.getAttribute(prop.replace(/_+[a-z]+/, ''));\n\n    if (!svgColors.includes(prop)) {\n      // attributes set with unit suffixes\n      if (currentValue !== null && regex.test(currentValue)) {\n        const unit = trueDimension(currentValue).u || trueDimension(attrObj[p]).u;\n        const suffix = /%/.test(unit) ? '_percent' : `_${unit}`;\n\n        // most \"unknown\" attributes cannot register into onStart, so we manually add them\n        onStart[ComponentName][prop + suffix] = (tp) => {\n          if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {\n            attributes[tp] = (elem, oneAttr, a, b, v) => {\n              const _p = oneAttr.replace(suffix, '');\n              /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n              elem.setAttribute(_p, ((numbers(a.v, b.v, v) * 1000 >> 0) / 1000) + b.u);\n            };\n          }\n        };\n        attributesObject[prop + suffix] = trueDimension(attrObj[p]);\n      } else if (!regex.test(attrObj[p]) || currentValue === null\n        || (currentValue && !regex.test(currentValue))) {\n        // most \"unknown\" attributes cannot register into onStart, so we manually add them\n        onStart[ComponentName][prop] = (tp) => {\n          if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {\n            attributes[tp] = (elem, oneAttr, a, b, v) => {\n              elem.setAttribute(oneAttr, (numbers(a, b, v) * 1000 >> 0) / 1000);\n            };\n          }\n        };\n        attributesObject[prop] = parseFloat(attrObj[p]);\n      }\n    } else { // colors\n      // most \"unknown\" attributes cannot register into onStart, so we manually add them\n      onStart[ComponentName][prop] = (tp) => {\n        if (this.valuesEnd[tweenProp] && this.valuesEnd[tweenProp][tp] && !(tp in attributes)) {\n          attributes[tp] = (elem, oneAttr, a, b, v) => {\n            elem.setAttribute(oneAttr, colors(a, b, v));\n          };\n        }\n      };\n      attributesObject[prop] = trueColor(attrObj[p]) || defaultValues.htmlAttributes[p];\n    }\n  });\n\n  return attributesObject;\n}\n\n// All Component Functions\nconst attrFunctions = {\n  prepareStart: getAttr,\n  prepareProperty: prepareAttr,\n  onStart: onStartAttr,\n};\n\n// Component Full\nconst htmlAttributes = {\n  component: ComponentName,\n  property: 'attr',\n  // the Animation class will need some values to validate this Object attribute\n  subProperties: ['fill', 'stroke', 'stop-color', 'fill-opacity', 'stroke-opacity'],\n  defaultValue: {\n    fill: 'rgb(0,0,0)',\n    stroke: 'rgb(0,0,0)',\n    'stop-color': 'rgb(0,0,0)',\n    opacity: 1,\n    'stroke-opacity': 1,\n    'fill-opacity': 1, // same here\n  },\n  Interpolate: { numbers, colors },\n  functions: attrFunctions,\n  // export to global for faster execution\n  Util: { replaceUppercase, trueColor, trueDimension },\n};\n\n/* opacityProperty = {\n  property: 'opacity',\n  defaultValue: 1,\n  interpolators: {numbers},\n  functions = { prepareStart, prepareProperty, onStart }\n} */\n\n// Component Functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartOpacity(tweenProp/* , value */) {\n  // opacity could be 0 sometimes, we need to check regardless\n  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      /* eslint-disable */\r\n      elem.style[tweenProp] = ((numbers(a, b, v) * 1000) >> 0) / 1000;\r\n      /* eslint-enable */\n    };\n  }\n}\n\n// Component Functions\n/**\n * Returns the current property computed style.\n * @param {string} tweenProp the property name\n * @returns {string} computed style for property\n */\nfunction getOpacity(tweenProp/* , value */) {\n  return getStyleForProperty(this.element, tweenProp);\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string} value the property value\n * @returns {number} the property tween object\n */\nfunction prepareOpacity(/* tweenProp, */_, value) {\n  return parseFloat(value); // opacity always FLOAT\n}\n\n// All Component Functions\nconst opacityFunctions = {\n  prepareStart: getOpacity,\n  prepareProperty: prepareOpacity,\n  onStart: onStartOpacity,\n};\n\n// Full Component\nconst OpacityProperty = {\n  component: 'opacityProperty',\n  property: 'opacity',\n  defaultValue: 1,\n  Interpolate: { numbers },\n  functions: opacityFunctions,\n};\n\n// Component Values\nconst lowerCaseAlpha = String('abcdefghijklmnopqrstuvwxyz').split(''); // lowercase\nconst upperCaseAlpha = String('abcdefghijklmnopqrstuvwxyz').toUpperCase().split(''); // uppercase\nconst nonAlpha = String(\"~!@#$%^&*()_+{}[];'<>,./?=-\").split(''); // symbols\nconst numeric = String('0123456789').split(''); // numeric\nconst alphaNumeric = lowerCaseAlpha.concat(upperCaseAlpha, numeric); // alpha numeric\nconst allTypes = alphaNumeric.concat(nonAlpha); // all caracters\n\nconst charSet = {\n  alpha: lowerCaseAlpha, // lowercase\n  upper: upperCaseAlpha, // uppercase\n  symbols: nonAlpha, // symbols\n  numeric,\n  alphanumeric: alphaNumeric,\n  all: allTypes,\n};\n\n// Component Functions\nconst onStartWrite = {\n  /**\n   * onStartWrite.text\n   *\n   * Sets the property update function.\n   * @param {string} tweenProp the property name\n   */\n  text(tweenProp) {\n    if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n      const chars = this._textChars;\n      let charsets = charSet[defaultOptions$1.textChars];\n\n      if (chars in charSet) {\n        charsets = charSet[chars];\n      } else if (chars && chars.length) {\n        charsets = chars;\n      }\n\n      KEC[tweenProp] = (elem, a, b, v) => {\n        let initialText = '';\n        let endText = '';\n        const finalText = b === '' ? ' ' : b;\n        const firstLetterA = a.substring(0);\n        const firstLetterB = b.substring(0);\n        /* eslint-disable */\r\n        const pointer = charsets[(Math.random() * charsets.length) >> 0];\r\n\r\n        if (a === ' ') {\r\n          endText = firstLetterB\r\n            .substring(Math.min(v * firstLetterB.length, firstLetterB.length) >> 0, 0);\r\n          elem.innerHTML = v < 1 ? ((endText + pointer)) : finalText;\r\n        } else if (b === ' ') {\r\n          initialText = firstLetterA\r\n            .substring(0, Math.min((1 - v) * firstLetterA.length, firstLetterA.length) >> 0);\r\n          elem.innerHTML = v < 1 ? ((initialText + pointer)) : finalText;\r\n        } else {\r\n          initialText = firstLetterA\r\n            .substring(firstLetterA.length,\r\n              Math.min(v * firstLetterA.length, firstLetterA.length) >> 0);\r\n          endText = firstLetterB\r\n            .substring(0, Math.min(v * firstLetterB.length, firstLetterB.length) >> 0);\r\n          elem.innerHTML = v < 1 ? ((endText + pointer + initialText)) : finalText;\r\n        }\r\n        /* eslint-enable */\n      };\n    }\n  },\n  /**\n   * onStartWrite.number\n   *\n   * Sets the property update function.\n   * @param {string} tweenProp the property name\n   */\n  number(tweenProp) {\n    if (tweenProp in this.valuesEnd && !KEC[tweenProp]) { // numbers can be 0\n      KEC[tweenProp] = (elem, a, b, v) => {\n        /* eslint-disable */\r\n        elem.innerHTML = numbers(a, b, v) >> 0;\r\n        /* eslint-enable */\n      };\n    }\n  },\n};\n\n// Component Util\n// utility for multi-child targets\n// wrapContentsSpan returns an [Element] with the SPAN.tagName and a desired class\nfunction wrapContentsSpan(el, classNAME) {\n  let textWriteWrapper;\n  let newElem;\n  if (typeof (el) === 'string') {\n    newElem = document.createElement('SPAN');\n    newElem.innerHTML = el;\n    newElem.className = classNAME;\n    return newElem;\n  }\n  if (!el.children.length || (el.children.length && el.children[0].className !== classNAME)) {\n    const elementInnerHTML = el.innerHTML;\n    textWriteWrapper = document.createElement('SPAN');\n    textWriteWrapper.className = classNAME;\n    textWriteWrapper.innerHTML = elementInnerHTML;\n    /* eslint-disable no-param-reassign -- impossible to satisfy */\n    el.appendChild(textWriteWrapper);\n    el.innerHTML = textWriteWrapper.outerHTML;\n    /* eslint-enable no-param-reassign -- impossible to satisfy */\n  } else if (el.children.length && el.children[0].className === classNAME) {\n    [textWriteWrapper] = el.children;\n  }\n  return textWriteWrapper;\n}\n\nfunction getTextPartsArray(el, classNAME) {\n  let elementsArray = [];\n  const len = el.children.length;\n  if (len) {\n    const textParts = [];\n    let remainingMarkup = el.innerHTML;\n    let wrapperParts;\n\n    for (let i = 0, currentChild, childOuter, unTaggedContent; i < len; i += 1) {\n      currentChild = el.children[i];\n      childOuter = currentChild.outerHTML;\n      wrapperParts = remainingMarkup.split(childOuter);\n\n      if (wrapperParts[0] !== '') {\n        unTaggedContent = wrapContentsSpan(wrapperParts[0], classNAME);\n        textParts.push(unTaggedContent);\n        remainingMarkup = remainingMarkup.replace(wrapperParts[0], '');\n      } else if (wrapperParts[1] !== '') {\n        unTaggedContent = wrapContentsSpan(wrapperParts[1].split('<')[0], classNAME);\n        textParts.push(unTaggedContent);\n        remainingMarkup = remainingMarkup.replace(wrapperParts[0].split('<')[0], '');\n      }\n\n      if (!currentChild.classList.contains(classNAME)) currentChild.classList.add(classNAME);\n      textParts.push(currentChild);\n      remainingMarkup = remainingMarkup.replace(childOuter, '');\n    }\n\n    if (remainingMarkup !== '') {\n      const unTaggedRemaining = wrapContentsSpan(remainingMarkup, classNAME);\n      textParts.push(unTaggedRemaining);\n    }\n\n    elementsArray = elementsArray.concat(textParts);\n  } else {\n    elementsArray = elementsArray.concat([wrapContentsSpan(el, classNAME)]);\n  }\n  return elementsArray;\n}\n\nfunction setSegments(target, newText) {\n  const oldTargetSegs = getTextPartsArray(target, 'text-part');\n  const newTargetSegs = getTextPartsArray(wrapContentsSpan(newText), 'text-part');\n\n  /* eslint-disable no-param-reassign */\n  target.innerHTML = '';\n  target.innerHTML += oldTargetSegs.map((s) => { s.className += ' oldText'; return s.outerHTML; }).join('');\n  target.innerHTML += newTargetSegs.map((s) => { s.className += ' newText'; return s.outerHTML.replace(s.innerHTML, ''); }).join('');\n  /* eslint-enable no-param-reassign */\n\n  return [oldTargetSegs, newTargetSegs];\n}\n\nfunction createTextTweens(target, newText, ops) {\n  if (target.playing) return false;\n\n  const options = ops || {};\n  options.duration = 1000;\n\n  if (ops.duration === 'auto') {\n    options.duration = 'auto';\n  } else if (Number.isFinite(ops.duration * 1)) {\n    options.duration = ops.duration * 1;\n  }\n\n  const TweenContructor = connect.tween;\n  const segs = setSegments(target, newText);\n  const oldTargetSegs = segs[0];\n  const newTargetSegs = segs[1];\n  const oldTargets = [].slice.call(target.getElementsByClassName('oldText')).reverse();\n  const newTargets = [].slice.call(target.getElementsByClassName('newText'));\n\n  let textTween = [];\n  let totalDelay = 0;\n\n  textTween = textTween.concat(oldTargets.map((el, i) => {\n    options.duration = options.duration === 'auto'\n      ? oldTargetSegs[i].innerHTML.length * 75\n      : options.duration;\n    options.delay = totalDelay;\n    options.onComplete = null;\n\n    totalDelay += options.duration;\n    return new TweenContructor(el, { text: el.innerHTML }, { text: '' }, options);\n  }));\n  textTween = textTween.concat(newTargets.map((el, i) => {\n    function onComplete() {\n      /* eslint-disable no-param-reassign */\n      target.innerHTML = newText;\n      target.playing = false;\n      /* eslint-enable no-param-reassign */\n    }\n\n    options.duration = options.duration === 'auto' ? newTargetSegs[i].innerHTML.length * 75 : options.duration;\n    options.delay = totalDelay;\n    options.onComplete = i === newTargetSegs.length - 1 ? onComplete : null;\n    totalDelay += options.duration;\n\n    return new TweenContructor(el, { text: '' }, { text: newTargetSegs[i].innerHTML }, options);\n  }));\n\n  textTween.start = function startTweens() {\n    if (!target.playing) {\n      textTween.forEach((tw) => tw.start());\n      // eslint-disable-next-line no-param-reassign\n      target.playing = true;\n    }\n  };\n\n  return textTween;\n}\n\n// Component Functions\n/**\n * Returns the current element `innerHTML`.\n * @returns {string} computed style for property\n */\nfunction getWrite(/* tweenProp, value */) {\n  return this.element.innerHTML;\n}\n\n/**\n * Returns the property tween object.\n * @param {string} tweenProp the property name\n * @param {string} value the property value\n * @returns {number | string} the property tween object\n */\nfunction prepareText(tweenProp, value) {\n  if (tweenProp === 'number') {\n    return parseFloat(value);\n  }\n  // empty strings crash the update function\n  return value === '' ? ' ' : value;\n}\n\n// All Component Functions\nconst textWriteFunctions = {\n  prepareStart: getWrite,\n  prepareProperty: prepareText,\n  onStart: onStartWrite,\n};\n\n// Full Component\nconst TextWrite = {\n  component: 'textWriteProperties',\n  category: 'textWrite',\n  properties: ['text', 'number'],\n  defaultValues: { text: ' ', number: '0' },\n  defaultOptions: { textChars: 'alpha' },\n  Interpolate: { numbers },\n  functions: textWriteFunctions,\n  // export to global for faster execution\n  Util: { charSet, createTextTweens },\n};\n\n/**\n * Perspective Interpolation Function.\n *\n * @param {number} a start value\n * @param {number} b end value\n * @param {string} u unit\n * @param {number} v progress\n * @returns {string} the perspective function in string format\n */\nfunction perspective(a, b, u, v) {\n  // eslint-disable-next-line no-bitwise\n  return `perspective(${((a + (b - a) * v) * 1000 >> 0) / 1000}${u})`;\n}\n\n/**\n * Translate 3D Interpolation Function.\n *\n * @param {number[]} a start [x,y,z] position\n * @param {number[]} b end [x,y,z] position\n * @param {string} u unit, usually `px` degrees\n * @param {number} v progress\n * @returns {string} the interpolated 3D translation string\n */\nfunction translate3d(a, b, u, v) {\n  const translateArray = [];\n  for (let ax = 0; ax < 3; ax += 1) {\n    translateArray[ax] = (a[ax] || b[ax]\n      // eslint-disable-next-line no-bitwise\n      ? ((a[ax] + (b[ax] - a[ax]) * v) * 1000 >> 0) / 1000 : 0) + u;\n  }\n  return `translate3d(${translateArray.join(',')})`;\n}\n\n/**\n * 3D Rotation Interpolation Function.\n *\n * @param {number} a start [x,y,z] angles\n * @param {number} b end [x,y,z] angles\n * @param {string} u unit, usually `deg` degrees\n * @param {number} v progress\n * @returns {string} the interpolated 3D rotation string\n */\nfunction rotate3d(a, b, u, v) {\n  let rotateStr = '';\n  // eslint-disable-next-line no-bitwise\n  rotateStr += a[0] || b[0] ? `rotateX(${((a[0] + (b[0] - a[0]) * v) * 1000 >> 0) / 1000}${u})` : '';\n  // eslint-disable-next-line no-bitwise\n  rotateStr += a[1] || b[1] ? `rotateY(${((a[1] + (b[1] - a[1]) * v) * 1000 >> 0) / 1000}${u})` : '';\n  // eslint-disable-next-line no-bitwise\n  rotateStr += a[2] || b[2] ? `rotateZ(${((a[2] + (b[2] - a[2]) * v) * 1000 >> 0) / 1000}${u})` : '';\n  return rotateStr;\n}\n\n/**\n * Translate 2D Interpolation Function.\n *\n * @param {number[]} a start [x,y] position\n * @param {number[]} b end [x,y] position\n * @param {string} u unit, usually `px` degrees\n * @param {number} v progress\n * @returns {string} the interpolated 2D translation string\n */\nfunction translate(a, b, u, v) {\n  const translateArray = [];\n  // eslint-disable-next-line no-bitwise\n  translateArray[0] = (a[0] === b[0] ? b[0] : ((a[0] + (b[0] - a[0]) * v) * 1000 >> 0) / 1000) + u;\n  // eslint-disable-next-line no-bitwise\n  translateArray[1] = a[1] || b[1] ? ((a[1] === b[1] ? b[1] : ((a[1] + (b[1] - a[1]) * v) * 1000 >> 0) / 1000) + u) : '0';\n  return `translate(${translateArray.join(',')})`;\n}\n\n/**\n * 2D Rotation Interpolation Function.\n *\n * @param {number} a start angle\n * @param {number} b end angle\n * @param {string} u unit, usually `deg` degrees\n * @param {number} v progress\n * @returns {string} the interpolated rotation\n */\nfunction rotate(a, b, u, v) {\n  // eslint-disable-next-line no-bitwise\n  return `rotate(${((a + (b - a) * v) * 1000 >> 0) / 1000}${u})`;\n}\n\n/**\n * Scale Interpolation Function.\n *\n * @param {number} a start scale\n * @param {number} b end scale\n * @param {number} v progress\n * @returns {string} the interpolated scale\n */\nfunction scale(a, b, v) {\n  // eslint-disable-next-line no-bitwise\n  return `scale(${((a + (b - a) * v) * 1000 >> 0) / 1000})`;\n}\n\n/**\n * Skew Interpolation Function.\n *\n * @param {number} a start {x,y} angles\n * @param {number} b end {x,y} angles\n * @param {string} u unit, usually `deg` degrees\n * @param {number} v progress\n * @returns {string} the interpolated string value of skew(s)\n */\nfunction skew(a, b, u, v) {\n  const skewArray = [];\n  // eslint-disable-next-line no-bitwise\n  skewArray[0] = (a[0] === b[0] ? b[0] : ((a[0] + (b[0] - a[0]) * v) * 1000 >> 0) / 1000) + u;\n  // eslint-disable-next-line no-bitwise\n  skewArray[1] = a[1] || b[1] ? ((a[1] === b[1] ? b[1] : ((a[1] + (b[1] - a[1]) * v) * 1000 >> 0) / 1000) + u) : '0';\n  return `skew(${skewArray.join(',')})`;\n}\n\n// Component Functions\n/**\n * Sets the property update function.\n * * same to svgTransform, htmlAttributes\n * @param {string} tweenProp the property name\n */\nfunction onStartTransform(tweenProp) {\n  if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      // eslint-disable-next-line no-param-reassign\n      elem.style[tweenProp] = (a.perspective || b.perspective ? perspective(a.perspective, b.perspective, 'px', v) : '') // one side might be 0\n        + (a.translate3d ? translate3d(a.translate3d, b.translate3d, 'px', v) : '') // array [x,y,z]\n        + (a.rotate3d ? rotate3d(a.rotate3d, b.rotate3d, 'deg', v) : '') // array [x,y,z]\n        + (a.skew ? skew(a.skew, b.skew, 'deg', v) : '') // array [x,y]\n        + (a.scale || b.scale ? scale(a.scale, b.scale, v) : ''); // one side might be 0\n    };\n  }\n}\n\n// same to svg transform, attr\n// the component developed for modern browsers supporting non-prefixed transform\n\n// Component Functions\n/**\n * Returns the current property inline style.\n * @param {string} tweenProp the property name\n * @returns {string} inline style for property\n */\nfunction getTransform(tweenProp/* , value */) {\n  const currentStyle = getInlineStyle(this.element);\n  return currentStyle[tweenProp] ? currentStyle[tweenProp] : defaultValues[tweenProp];\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {Object<string, string | number | (string | number)[]>} obj the property value\n * @returns {KUTE.transformFObject} the property tween object\n */\nfunction prepareTransform(/* prop, */_, obj) {\n  const prepAxis = ['X', 'Y', 'Z']; // coordinates\n  const transformObject = {};\n  const translateArray = []; const rotateArray = []; const skewArray = [];\n  const arrayFunctions = ['translate3d', 'translate', 'rotate3d', 'skew'];\n\n  Object.keys(obj).forEach((x) => {\n    const pv = typeof obj[x] === 'object' && obj[x].length\n      ? obj[x].map((v) => parseInt(v, 10))\n      : parseInt(obj[x], 10);\n\n    if (arrayFunctions.includes(x)) {\n      const propId = x === 'translate' || x === 'rotate' ? `${x}3d` : x;\n\n      if (x === 'skew') {\n        transformObject[propId] = pv.length\n          ? [pv[0] || 0, pv[1] || 0]\n          : [pv || 0, 0];\n      } else if (x === 'translate') {\n        transformObject[propId] = pv.length\n          ? [pv[0] || 0, pv[1] || 0, pv[2] || 0]\n          : [pv || 0, 0, 0];\n      } else { // translate3d | rotate3d\n        transformObject[propId] = [pv[0] || 0, pv[1] || 0, pv[2] || 0];\n      }\n    } else if (/[XYZ]/.test(x)) {\n      const fn = x.replace(/[XYZ]/, '');\n      const fnId = fn === 'skew' ? fn : `${fn}3d`;\n      const fnLen = fn === 'skew' ? 2 : 3;\n      let fnArray = [];\n\n      if (fn === 'translate') {\n        fnArray = translateArray;\n      } else if (fn === 'rotate') {\n        fnArray = rotateArray;\n      } else if (fn === 'skew') {\n        fnArray = skewArray;\n      }\n\n      for (let fnIndex = 0; fnIndex < fnLen; fnIndex += 1) {\n        const fnAxis = prepAxis[fnIndex];\n        fnArray[fnIndex] = (`${fn}${fnAxis}` in obj) ? parseInt(obj[`${fn}${fnAxis}`], 10) : 0;\n      }\n      transformObject[fnId] = fnArray;\n    } else if (x === 'rotate') { //  rotate\n      transformObject.rotate3d = [0, 0, pv];\n    } else { // scale | perspective\n      transformObject[x] = x === 'scale' ? parseFloat(obj[x]) : pv;\n    }\n  });\n\n  return transformObject;\n}\n\n/**\n * Prepare tween object in advance for `to()` method.\n * @param {string} tweenProp the property name\n */\nfunction crossCheckTransform(tweenProp) {\n  if (this.valuesEnd[tweenProp]) {\n    if (this.valuesEnd[tweenProp]) {\n      if (this.valuesEnd[tweenProp].perspective && !this.valuesStart[tweenProp].perspective) {\n        this.valuesStart[tweenProp].perspective = this.valuesEnd[tweenProp].perspective;\n      }\n    }\n  }\n}\n\n// All Component Functions\nconst transformFunctions = {\n  prepareStart: getTransform,\n  prepareProperty: prepareTransform,\n  onStart: onStartTransform,\n  crossCheck: crossCheckTransform,\n};\n\nconst supportedTransformProperties = [\n  'perspective',\n  'translate3d', 'translateX', 'translateY', 'translateZ', 'translate',\n  'rotate3d', 'rotateX', 'rotateY', 'rotateZ', 'rotate',\n  'skewX', 'skewY', 'skew',\n  'scale',\n];\n\nconst defaultTransformValues = {\n  perspective: 400,\n  translate3d: [0, 0, 0],\n  translateX: 0,\n  translateY: 0,\n  translateZ: 0,\n  translate: [0, 0],\n  rotate3d: [0, 0, 0],\n  rotateX: 0,\n  rotateY: 0,\n  rotateZ: 0,\n  rotate: 0,\n  skewX: 0,\n  skewY: 0,\n  skew: [0, 0],\n  scale: 1,\n};\n\n// Full Component\nconst TransformFunctions = {\n  component: 'transformFunctions',\n  property: 'transform',\n  subProperties: supportedTransformProperties,\n  defaultValues: defaultTransformValues,\n  functions: transformFunctions,\n  Interpolate: {\n    perspective,\n    translate3d,\n    rotate3d,\n    translate,\n    rotate,\n    scale,\n    skew,\n  },\n};\n\n// Component Functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartDraw(tweenProp) {\n  if (tweenProp in this.valuesEnd && !KEC[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      /* eslint-disable no-bitwise -- impossible to satisfy */\n      const pathLength = (a.l * 100 >> 0) / 100;\n      const start = (numbers(a.s, b.s, v) * 100 >> 0) / 100;\n      const end = (numbers(a.e, b.e, v) * 100 >> 0) / 100;\n      const offset = 0 - start;\n      const dashOne = end + offset;\n      // eslint-disable-next-line no-param-reassign -- impossible to satisfy\n      elem.style.strokeDashoffset = `${offset}px`;\n      // eslint-disable-next-line no-param-reassign -- impossible to satisfy\n      elem.style.strokeDasharray = `${((dashOne < 1 ? 0 : dashOne) * 100 >> 0) / 100}px, ${pathLength}px`;\n      /* eslint-disable no-bitwise -- impossible to satisfy */\n    };\n  }\n}\n\n// Component Util\n/**\n * Convert a `<path>` length percent value to absolute.\n * @param {string} v raw value\n * @param {number} l length value\n * @returns {number} the absolute value\n */\nfunction percent(v, l) {\n  return (parseFloat(v) / 100) * l;\n}\n\n/**\n * Returns the `<rect>` length.\n * It doesn't compute `rx` and / or `ry` of the element.\n * @see http://stackoverflow.com/a/30376660\n * @param {SVGRectElement} el target element\n * @returns {number} the `<rect>` length\n */\nfunction getRectLength(el) {\n  const w = el.getAttribute('width');\n  const h = el.getAttribute('height');\n  return (w * 2) + (h * 2);\n}\n\n/**\n * Returns the `<polyline>` / `<polygon>` length.\n * @param {SVGPolylineElement | SVGPolygonElement} el target element\n * @returns {number} the element length\n */\nfunction getPolyLength(el) {\n  const points = el.getAttribute('points').split(' ');\n\n  let len = 0;\n  if (points.length > 1) {\n    const coord = (p) => {\n      const c = p.split(',');\n      if (c.length !== 2) { return 0; } // return undefined\n      if (Number.isNaN(c[0] * 1) || Number.isNaN(c[1] * 1)) { return 0; }\n      return [parseFloat(c[0]), parseFloat(c[1])];\n    };\n\n    const dist = (c1, c2) => {\n      if (c1 !== undefined && c2 !== undefined) {\n        return Math.sqrt((c2[0] - c1[0]) ** 2 + (c2[1] - c1[1]) ** 2);\n      }\n      return 0;\n    };\n\n    if (points.length > 2) {\n      for (let i = 0; i < points.length - 1; i += 1) {\n        len += dist(coord(points[i]), coord(points[i + 1]));\n      }\n    }\n    len += el.tagName === 'polygon'\n      ? dist(coord(points[0]), coord(points[points.length - 1])) : 0;\n  }\n  return len;\n}\n\n/**\n * Returns the `<line>` length.\n * @param {SVGLineElement} el target element\n * @returns {number} the element length\n */\nfunction getLineLength(el) {\n  const x1 = el.getAttribute('x1');\n  const x2 = el.getAttribute('x2');\n  const y1 = el.getAttribute('y1');\n  const y2 = el.getAttribute('y2');\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n}\n\n/**\n * Returns the `<circle>` length.\n * @param {SVGCircleElement} el target element\n * @returns {number} the element length\n */\nfunction getCircleLength(el) {\n  const r = el.getAttribute('r');\n  return 2 * Math.PI * r;\n}\n\n// returns the length of an ellipse\n/**\n * Returns the `<ellipse>` length.\n * @param {SVGEllipseElement} el target element\n * @returns {number} the element length\n */\nfunction getEllipseLength(el) {\n  const rx = el.getAttribute('rx');\n  const ry = el.getAttribute('ry');\n  const len = 2 * rx;\n  const wid = 2 * ry;\n  return ((Math.sqrt(0.5 * ((len * len) + (wid * wid)))) * (Math.PI * 2)) / 2;\n}\n\n/**\n * Returns the shape length.\n * @param {SVGPathCommander.shapeTypes} el target element\n * @returns {number} the element length\n */\nfunction getTotalLength$1(el) {\n  if (el.tagName === 'rect') {\n    return getRectLength(el);\n  } if (el.tagName === 'circle') {\n    return getCircleLength(el);\n  } if (el.tagName === 'ellipse') {\n    return getEllipseLength(el);\n  } if (['polygon', 'polyline'].includes(el.tagName)) {\n    return getPolyLength(el);\n  } if (el.tagName === 'line') {\n    return getLineLength(el);\n  }\n  // ESLint\n  return 0;\n}\n\n/**\n * Returns the property tween object.\n * @param {SVGPathCommander.shapeTypes} element the target element\n * @param {string | KUTE.drawObject} value the property value\n * @returns {KUTE.drawObject} the property tween object\n */\nfunction getDraw(element, value) {\n  const length = /path|glyph/.test(element.tagName)\n    ? element.getTotalLength()\n    : getTotalLength$1(element);\n  let start;\n  let end;\n  let dasharray;\n  let offset;\n\n  if (value instanceof Object && Object.keys(value).every((v) => ['s', 'e', 'l'].includes(v))) {\n    return value;\n  } if (typeof value === 'string') {\n    const v = value.split(/,|\\s/);\n    start = /%/.test(v[0]) ? percent(v[0].trim(), length) : parseFloat(v[0]);\n    end = /%/.test(v[1]) ? percent(v[1].trim(), length) : parseFloat(v[1]);\n  } else if (typeof value === 'undefined') {\n    offset = parseFloat(getStyleForProperty(element, 'stroke-dashoffset'));\n    dasharray = getStyleForProperty(element, 'stroke-dasharray').split(',');\n\n    start = 0 - offset;\n    end = parseFloat(dasharray[0]) + start || length;\n  }\n  return { s: start, e: end, l: length };\n}\n\n/**\n * Reset CSS properties associated with the `draw` property.\n * @param {SVGPathCommander.shapeTypes} element target\n */\nfunction resetDraw(elem) {\n  /* eslint-disable no-param-reassign -- impossible to satisfy */\n  elem.style.strokeDashoffset = '';\n  elem.style.strokeDasharray = '';\n  /* eslint-disable no-param-reassign -- impossible to satisfy */\n}\n\n// Component Functions\n/**\n * Returns the property tween object.\n * @returns {KUTE.drawObject} the property tween object\n */\nfunction getDrawValue(/* prop, value */) {\n  return getDraw(this.element);\n}\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string | KUTE.drawObject} value the property value\n * @returns {KUTE.drawObject} the property tween object\n */\nfunction prepareDraw(_, value) {\n  return getDraw(this.element, value);\n}\n\n// All Component Functions\nconst svgDrawFunctions = {\n  prepareStart: getDrawValue,\n  prepareProperty: prepareDraw,\n  onStart: onStartDraw,\n};\n\n// Component Full\nconst SvgDrawProperty = {\n  component: 'svgDraw',\n  property: 'draw',\n  defaultValue: '0% 0%',\n  Interpolate: { numbers },\n  functions: svgDrawFunctions,\n  // Export to global for faster execution\n  Util: {\n    getRectLength,\n    getPolyLength,\n    getLineLength,\n    getCircleLength,\n    getEllipseLength,\n    getTotalLength: getTotalLength$1,\n    resetDraw,\n    getDraw,\n    percent,\n  },\n};\n\n/**\n * Splits an extended A (arc-to) segment into two cubic-bezier segments.\n *\n * @param {SVGPath.pathArray} path the `pathArray` this segment belongs to\n * @param {string[]} allPathCommands all previous path commands\n * @param {number} i the segment index\n */\n\nfunction fixArc(path, allPathCommands, i) {\n  if (path[i].length > 7) {\n    path[i].shift();\n    const segment = path[i];\n    let ni = i; // ESLint\n    while (segment.length) {\n      // if created multiple C:s, their original seg is saved\n      allPathCommands[i] = 'A';\n      path.splice(ni += 1, 0, ['C', ...segment.splice(0, 6)]);\n    }\n    path.splice(i, 1);\n  }\n}\n\n/**\n * Segment params length\n * @type {Record<string, number>}\n */\nconst paramsCount = {\n  a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0,\n};\n\n/**\n * Iterates an array to check if it's an actual `pathArray`.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nfunction isPathArray(path) {\n  return Array.isArray(path) && path.every((seg) => {\n    const lk = seg[0].toLowerCase();\n    return paramsCount[lk] === seg.length - 1 && 'achlmqstvz'.includes(lk);\n  });\n}\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nfunction isAbsoluteArray(path) {\n  return isPathArray(path)\n    // `isPathArray` also checks if it's `Array`\n    && path.every(([x]) => x === x.toUpperCase());\n}\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all segments are in non-shorthand notation\n * with absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nfunction isNormalizedArray(path) {\n  // `isAbsoluteArray` also checks if it's `Array`\n  return isAbsoluteArray(path) && path.every(([pc]) => 'ACLMQZ'.includes(pc));\n}\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all C (cubic bezier) segments.\n *\n * @param {string | SVGPath.pathArray} path the `Array` to be checked\n * @returns {boolean} iteration result\n */\nfunction isCurveArray(path) {\n  // `isPathArray` also checks if it's `Array`\n  return isNormalizedArray(path) && path.every(([pc]) => 'MC'.includes(pc));\n}\n\n/**\n * Returns a clone of an existing `pathArray`.\n *\n * @param {SVGPath.pathArray | SVGPath.pathSegment} path the source `pathArray`\n * @returns {any} the cloned `pathArray`\n */\nfunction clonePath(path) {\n  return path.map((x) => (Array.isArray(x) ? [...x] : x));\n}\n\n/**\n * Breaks the parsing of a pathString once a segment is finalized.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction finalizeSegment(path) {\n  let pathCommand = path.pathValue[path.segmentStart];\n  let LK = pathCommand.toLowerCase();\n  const { data } = path;\n\n  while (data.length >= paramsCount[LK]) {\n    // overloaded `moveTo`\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\n    if (LK === 'm' && data.length > 2) {\n      path.segments.push([pathCommand, ...data.splice(0, 2)]);\n      LK = 'l';\n      pathCommand = pathCommand === 'm' ? 'l' : 'L';\n    } else {\n      path.segments.push([pathCommand, ...data.splice(0, paramsCount[LK])]);\n    }\n\n    if (!paramsCount[LK]) {\n      break;\n    }\n  }\n}\n\nconst error = 'SVGPathCommander error';\n\n/**\n * Validates an A (arc-to) specific path command value.\n * Usually a `large-arc-flag` or `sweep-flag`.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction scanFlag(path) {\n  const { index, pathValue } = path;\n  const code = pathValue.charCodeAt(index);\n\n  if (code === 0x30/* 0 */) {\n    path.param = 0;\n    path.index += 1;\n    return;\n  }\n\n  if (code === 0x31/* 1 */) {\n    path.param = 1;\n    path.index += 1;\n    return;\n  }\n\n  path.err = `${error}: invalid Arc flag \"${pathValue[index]}\", expecting 0 or 1 at index ${index}`;\n}\n\n/**\n * Checks if a character is a digit.\n *\n * @param {number} code the character to check\n * @returns {boolean} check result\n */\nfunction isDigit(code) {\n  return (code >= 48 && code <= 57); // 0..9\n}\n\nconst invalidPathValue = 'Invalid path value';\n\n/**\n * Validates every character of the path string,\n * every path command, negative numbers or floating point numbers.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction scanParam(path) {\n  const { max, pathValue, index: start } = path;\n  let index = start;\n  let zeroFirst = false;\n  let hasCeiling = false;\n  let hasDecimal = false;\n  let hasDot = false;\n  let ch;\n\n  if (index >= max) {\n    // path.err = 'SvgPath: missed param (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\n    return;\n  }\n  ch = pathValue.charCodeAt(index);\n\n  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n    index += 1;\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\n    ch = pathValue.charCodeAt(index);\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  if (!isDigit(ch) && ch !== 0x2E/* . */) {\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" is not a number`;\n    return;\n  }\n\n  if (ch !== 0x2E/* . */) {\n    zeroFirst = (ch === 0x30/* 0 */);\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\n        // are illegal (at pos ' + start + ')';\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${pathValue[start]}\" illegal number`;\n        return;\n      }\n    }\n\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasCeiling = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x2E/* . */) {\n    hasDot = true;\n    index += 1;\n    while (isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasDecimal = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x65/* e */ || ch === 0x45/* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid float exponent`;\n      return;\n    }\n\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      index += 1;\n    }\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\n        index += 1;\n      }\n    } else {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid integer exponent`;\n      return;\n    }\n  }\n\n  path.index = index;\n  path.param = +path.pathValue.slice(start, index);\n}\n\n/**\n * Checks if the character is a space.\n *\n * @param {number} ch the character to check\n * @returns {boolean} check result\n */\nfunction isSpace(ch) {\n  const specialSpaces = [\n    0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,\n    0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];\n  /* istanbul ignore next */\n  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) // Line terminators\n    // White spaces\n    || (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0)\n    || (ch >= 0x1680 && specialSpaces.includes(ch));\n}\n\n/**\n * Points the parser to the next character in the\n * path string every time it encounters any kind of\n * space character.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction skipSpaces(path) {\n  const { pathValue, max } = path;\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\n    path.index += 1;\n  }\n}\n\n/**\n * Checks if the character is a path command.\n *\n * @param {any} code the character to check\n * @returns {boolean} check result\n */\nfunction isPathCommand(code) {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6D/* m */:\n    case 0x7A/* z */:\n    case 0x6C/* l */:\n    case 0x68/* h */:\n    case 0x76/* v */:\n    case 0x63/* c */:\n    case 0x73/* s */:\n    case 0x71/* q */:\n    case 0x74/* t */:\n    case 0x61/* a */:\n    // case 0x72/* r */:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Checks if the character is or belongs to a number.\n * [0-9]|+|-|.\n *\n * @param {number} code the character to check\n * @returns {boolean} check result\n */\nfunction isDigitStart(code) {\n  return (code >= 48 && code <= 57) /* 0..9 */\n    || code === 0x2B /* + */\n    || code === 0x2D /* - */\n    || code === 0x2E; /* . */\n}\n\n/**\n * Checks if the character is an A (arc-to) path command.\n *\n * @param {number} code the character to check\n * @returns {boolean} check result\n */\nfunction isArcCommand(code) {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  return (code | 0x20) === 0x61;\n}\n\n/**\n * Scans every character in the path string to determine\n * where a segment starts and where it ends.\n *\n * @param {SVGPath.PathParser} path the `PathParser` instance\n */\nfunction scanSegment(path) {\n  const { max, pathValue, index } = path;\n  const cmdCode = pathValue.charCodeAt(index);\n  const reqParams = paramsCount[pathValue[index].toLowerCase()];\n\n  path.segmentStart = index;\n\n  if (!isPathCommand(cmdCode)) {\n    path.err = `${error}: ${invalidPathValue} \"${pathValue[index]}\" is not a path command`;\n    return;\n  }\n\n  path.index += 1;\n  skipSpaces(path);\n\n  path.data = [];\n\n  if (!reqParams) {\n    // Z\n    finalizeSegment(path);\n    return;\n  }\n\n  for (;;) {\n    for (let i = reqParams; i > 0; i -= 1) {\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);\n      else scanParam(path);\n\n      if (path.err.length) {\n        return;\n      }\n      path.data.push(path.param);\n\n      skipSpaces(path);\n\n      // after ',' param is mandatory\n      if (path.index < max && pathValue.charCodeAt(path.index) === 0x2C/* , */) {\n        path.index += 1;\n        skipSpaces(path);\n      }\n    }\n\n    if (path.index >= path.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(path);\n}\n\n/**\n * The `PathParser` is used by the `parsePathString` static method\n * to generate a `pathArray`.\n *\n * @param {string} pathString\n */\nfunction PathParser(pathString) {\n  /** @type {SVGPath.pathArray} */\n  this.segments = [];\n  /** @type {string} */\n  this.pathValue = pathString;\n  /** @type {number} */\n  this.max = pathString.length;\n  /** @type {number} */\n  this.index = 0;\n  /** @type {number} */\n  this.param = 0.0;\n  /** @type {number} */\n  this.segmentStart = 0;\n  /** @type {any} */\n  this.data = [];\n  /** @type {string} */\n  this.err = '';\n}\n\n/**\n * Parses a path string value and returns an array\n * of segments we like to call `pathArray`.\n *\n * @param {SVGPath.pathArray | string} pathInput the string to be parsed\n * @returns {SVGPath.pathArray | string} the resulted `pathArray` or error string\n */\nfunction parsePathString(pathInput) {\n  if (isPathArray(pathInput)) {\n    return clonePath(pathInput);\n  }\n\n  const path = new PathParser(pathInput);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  return path.err ? path.err : path.segments;\n}\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to absolute values.\n *\n * @param {string | SVGPath.pathArray} pathInput the path string | object\n * @returns {SVGPath.absoluteArray} the resulted `pathArray` with absolute values\n */\nfunction pathToAbsolute(pathInput) {\n  /* istanbul ignore else */\n  if (isAbsoluteArray(pathInput)) {\n    // `isAbsoluteArray` checks if it's `pathArray`\n    return clonePath(pathInput);\n  }\n\n  const path = parsePathString(pathInput);\n  let x = 0; let y = 0;\n  let mx = 0; let my = 0;\n\n  // the `absoluteSegment[]` is for sure an `absolutePath`\n  return path.map((segment) => {\n    const values = segment.slice(1).map(Number);\n    const [pathCommand] = segment;\n    /** @type {SVGPath.absoluteCommand} */\n    const absCommand = pathCommand.toUpperCase();\n\n    if (pathCommand === 'M') {\n      [x, y] = values;\n      mx = x;\n      my = y;\n      return ['M', x, y];\n    }\n    /** @type {SVGPath.absoluteSegment} */\n    let absoluteSegment = [];\n\n    if (pathCommand !== absCommand) {\n      switch (absCommand) {\n        case 'A':\n          absoluteSegment = [\n            absCommand, values[0], values[1], values[2],\n            values[3], values[4], values[5] + x, values[6] + y];\n          break;\n        case 'V':\n          absoluteSegment = [absCommand, values[0] + y];\n          break;\n        case 'H':\n          absoluteSegment = [absCommand, values[0] + x];\n          break;\n        default: {\n          // use brakets for `eslint: no-case-declaration`\n          // https://stackoverflow.com/a/50753272/803358\n          const absValues = values.map((n, j) => n + (j % 2 ? y : x));\n          // for n, l, c, s, q, t\n          absoluteSegment = [absCommand, ...absValues];\n        }\n      }\n    } else {\n      absoluteSegment = [absCommand, ...values];\n    }\n\n    const segLength = absoluteSegment.length;\n    switch (absCommand) {\n      case 'Z':\n        x = mx;\n        y = my;\n        break;\n      case 'H':\n        [, x] = absoluteSegment;\n        break;\n      case 'V':\n        [, y] = absoluteSegment;\n        break;\n      default:\n        x = absoluteSegment[segLength - 2];\n        y = absoluteSegment[segLength - 1];\n\n        if (absCommand === 'M') {\n          mx = x;\n          my = y;\n        }\n    }\n    return absoluteSegment;\n  });\n}\n\n/**\n * Normalizes a single segment of a `pathArray` object.\n *\n * @param {SVGPath.pathSegment} segment the segment object\n * @param {any} params the coordinates of the previous segment\n * @returns {SVGPath.normalSegment} the normalized segment\n */\nfunction normalizeSegment(segment, params) {\n  const [pathCommand] = segment;\n  const {\n    x1: px1, y1: py1, x2: px2, y2: py2,\n  } = params;\n  const values = segment.slice(1).map(Number);\n  let result = segment;\n\n  if (!'TQ'.includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === 'H') {\n    result = ['L', segment[1], py1];\n  } else if (pathCommand === 'V') {\n    result = ['L', px1, segment[1]];\n  } else if (pathCommand === 'S') {\n    const x1 = px1 * 2 - px2;\n    const y1 = py1 * 2 - py2;\n    params.x1 = x1;\n    params.y1 = y1;\n    result = ['C', x1, y1, ...values];\n  } else if (pathCommand === 'T') {\n    const qx = px1 * 2 - params.qx;\n    const qy = py1 * 2 - params.qy;\n    params.qx = qx;\n    params.qy = qy;\n    result = ['Q', qx, qy, ...values];\n  } else if (pathCommand === 'Q') {\n    const [nqx, nqy] = values;\n    params.qx = nqx;\n    params.qy = nqy;\n  }\n\n  return result;\n}\n\n/**\n * @type {SVGPath.parserParams}\n */\nconst paramsParser = {\n  x1: 0, y1: 0, x2: 0, y2: 0, x: 0, y: 0, qx: null, qy: null,\n};\n\n/**\n * Normalizes a `path` object for further processing:\n * * convert segments to absolute values\n * * convert shorthand path commands to their non-shorthand notation\n *\n * @param {string | SVGPath.pathArray} pathInput the string to be parsed or 'pathArray'\n * @returns {SVGPath.normalArray} the normalized `pathArray`\n */\nfunction normalizePath(pathInput) {\n  if (isNormalizedArray(pathInput)) {\n    return clonePath(pathInput);\n  }\n\n  /** @type {SVGPath.normalArray} */\n  const path = pathToAbsolute(pathInput);\n  const params = { ...paramsParser };\n  const ii = path.length;\n\n  for (let i = 0; i < ii; i += 1) {\n    path[i];\n    path[i] = normalizeSegment(path[i], params);\n\n    const segment = path[i];\n    const seglen = segment.length;\n\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +(segment[seglen - 4]) || params.x1;\n    params.y2 = +(segment[seglen - 3]) || params.y1;\n  }\n\n  return path;\n}\n\n/**\n * Returns an {x,y} vector rotated by a given\n * angle in radian.\n *\n * @param {number} x the initial vector x\n * @param {number} y the initial vector y\n * @param {number} rad the radian vector angle\n * @returns {{x: number, y: number}} the rotated vector\n */\nfunction rotateVector(x, y, rad) {\n  const X = x * Math.cos(rad) - y * Math.sin(rad);\n  const Y = x * Math.sin(rad) + y * Math.cos(rad);\n  return { x: X, y: Y };\n}\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n *\n * @param {number} X1 the starting x position\n * @param {number} Y1 the starting y position\n * @param {number} RX x-radius of the arc\n * @param {number} RY y-radius of the arc\n * @param {number} angle x-axis-rotation of the arc\n * @param {number} LAF large-arc-flag of the arc\n * @param {number} SF sweep-flag of the arc\n * @param {number} X2 the ending x position\n * @param {number} Y2 the ending y position\n * @param {number[]=} recursive the parameters needed to split arc into 2 segments\n * @return {number[]} the resulting cubic-bezier segment(s)\n */\nfunction arcToCubic(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, recursive) {\n  let x1 = X1; let y1 = Y1; let rx = RX; let ry = RY; let x2 = X2; let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = (Math.PI * 120) / 180;\n\n  const rad = (Math.PI / 180) * (+angle || 0);\n  /** @type {number[]} */\n  let res = [];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n\n    const k = (LAF === SF ? -1 : 1)\n            * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x)\n                / (rx2 * y * y + ry2 * x * x)));\n\n    cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n    cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin((((y1 - cy) / ry) * (10 ** 9) >> 0) / (10 ** 9));\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin((((y2 - cy) / ry) * (10 ** 9) >> 0) / (10 ** 9));\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) (f1 = Math.PI * 2 + f1);\n    if (f2 < 0) (f2 = Math.PI * 2 + f2);\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = (4 / 3) * rx * t;\n  const hy = (4 / 3) * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [...m2, ...m3, ...m4, ...res];\n  }\n  res = [...m2, ...m3, ...m4, ...res];\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2\n      ? rotateVector(res[i - 1], res[i], rad).y\n      : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n}\n\n/**\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\n *\n * @param {number} x1 curve start x\n * @param {number} y1 curve start y\n * @param {number} qx control point x\n * @param {number} qy control point y\n * @param {number} x2 curve end x\n * @param {number} y2 curve end y\n * @returns {number[]} the cubic-bezier segment\n */\nfunction quadToCubic(x1, y1, qx, qy, x2, y2) {\n  const r13 = 1 / 3;\n  const r23 = 2 / 3;\n  return [\n    r13 * x1 + r23 * qx, // cpx1\n    r13 * y1 + r23 * qy, // cpy1\n    r13 * x2 + r23 * qx, // cpx2\n    r13 * y2 + r23 * qy, // cpy2\n    x2, y2, // x,y\n  ];\n}\n\n/**\n * Returns the coordinates of a specified distance\n * ratio between two points.\n *\n * @param {[number, number]} a the first point coordinates\n * @param {[number, number]} b the second point coordinates\n * @param {number} t the ratio\n * @returns {[number, number]} the midpoint coordinates\n */\nfunction midPoint(a, b, t) {\n  const [ax, ay] = a; const [bx, by] = b;\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\n}\n\n/**\n * Returns the square root of the distance\n * between two given points.\n *\n * @param {[number, number]} a the first point coordinates\n * @param {[number, number]} b the second point coordinates\n * @returns {number} the distance value\n */\nfunction distanceSquareRoot(a, b) {\n  return Math.sqrt(\n    (a[0] - b[0]) * (a[0] - b[0])\n    + (a[1] - b[1]) * (a[1] - b[1]),\n  );\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a line (L,V,H,Z) segment.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number=} distance the distance to point\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentLineFactory(x1, y1, x2, y2, distance) {\n  const length = distanceSquareRoot([x1, y1], [x2, y2]);\n  let point = { x: 0, y: 0 };\n\n  /* istanbul ignore else */\n  if (typeof distance === 'number') {\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x: x2, y: y2 };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\n      point = { x, y };\n    }\n  }\n\n  return {\n    length,\n    point,\n    min: {\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n    },\n    max: {\n      x: Math.max(x1, x2),\n      y: Math.max(y1, y2),\n    },\n  };\n}\n\n/**\n * Converts an L (line-to) segment to C (cubic-bezier).\n *\n * @param {number} x1 line start x\n * @param {number} y1 line start y\n * @param {number} x2 line end x\n * @param {number} y2 line end y\n * @returns {number[]} the cubic-bezier segment\n */\nfunction lineToCubic(x1, y1, x2, y2) {\n  const t = 0.5;\n  /** @type {[number, number]} */\n  const p0 = [x1, y1];\n  /** @type {[number, number]} */\n  const p1 = [x2, y2];\n  const p2 = midPoint(p0, p1, t);\n  const p3 = midPoint(p1, p2, t);\n  const p4 = midPoint(p2, p3, t);\n  const p5 = midPoint(p3, p4, t);\n  const p6 = midPoint(p4, p5, t);\n  const seg1 = [...p0, ...p2, ...p4, ...p6, t];\n  const cp1 = segmentLineFactory(...seg1).point;\n  const seg2 = [...p6, ...p5, ...p3, ...p1, 0];\n  const cp2 = segmentLineFactory(...seg2).point;\n\n  return [cp1.x, cp1.y, cp2.x, cp2.y, x2, y2];\n}\n\n/**\n * Converts any segment to C (cubic-bezier).\n *\n * @param {SVGPath.pathSegment} segment the source segment\n * @param {SVGPath.parserParams} params the source segment parameters\n * @returns {SVGPath.cubicSegment | SVGPath.MSegment} the cubic-bezier segment\n */\nfunction segmentToCubic(segment, params) {\n  const [pathCommand] = segment;\n  const values = segment.slice(1).map(Number);\n  const [x, y] = values;\n  let args;\n  const {\n    x1: px1, y1: py1, x: px, y: py,\n  } = params;\n\n  if (!'TQ'.includes(pathCommand)) {\n    params.qx = null;\n    params.qy = null;\n  }\n\n  switch (pathCommand) {\n    case 'M':\n      params.x = x;\n      params.y = y;\n      return segment;\n    case 'A':\n      args = [px1, py1, ...values];\n      return ['C', ...arcToCubic(...args)];\n    case 'Q':\n      params.qx = x;\n      params.qy = y;\n      args = [px1, py1, ...values];\n      return ['C', ...quadToCubic(...args)];\n    case 'L':\n      return ['C', ...lineToCubic(px1, py1, x, y)];\n    case 'Z':\n      return ['C', ...lineToCubic(px1, py1, px, py)];\n  }\n  return segment;\n}\n\n/**\n * Parses a path string value or 'pathArray' and returns a new one\n * in which all segments are converted to cubic-bezier.\n *\n * In addition, un-necessary `Z` segment is removed if previous segment\n * extends to the `M` segment.\n *\n * @param {string | SVGPath.pathArray} pathInput the string to be parsed or 'pathArray'\n * @returns {SVGPath.curveArray} the resulted `pathArray` converted to cubic-bezier\n */\nfunction pathToCurve(pathInput) {\n  /* istanbul ignore else */\n  if (isCurveArray(pathInput)) {\n    // `isCurveArray` checks if it's `pathArray`\n    return clonePath(pathInput);\n  }\n\n  // const path = fixPath(normalizePath(pathInput));\n  const path = normalizePath(pathInput);\n  const params = { ...paramsParser };\n  const allPathCommands = [];\n  let pathCommand = ''; // ts-lint\n  let ii = path.length;\n\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n    allPathCommands[i] = pathCommand;\n\n    path[i] = segmentToCubic(path[i], params);\n\n    fixArc(path, allPathCommands, i);\n    ii = path.length;\n\n    const segment = path[i];\n    const seglen = segment.length;\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +(segment[seglen - 4]) || params.x1;\n    params.y2 = +(segment[seglen - 3]) || params.y1;\n  }\n\n  return path;\n}\n\n/**\n * SVGPathCommander default options\n * @type {SVGPath.options}\n */\nconst defaultOptions = {\n  origin: [0, 0, 0],\n  round: 4,\n};\n\n/**\n * Rounds the values of a `pathArray` instance to\n * a specified amount of decimals and returns it.\n *\n * @param {SVGPath.pathArray} path the source `pathArray`\n * @param {number | 'off'} roundOption the amount of decimals to round numbers to\n * @returns {SVGPath.pathArray} the resulted `pathArray` with rounded values\n */\nfunction roundPath(path, roundOption) {\n  let { round } = defaultOptions;\n  if (roundOption === 'off' || round === 'off') return clonePath(path);\n  // round = roundOption >= 1 ? roundOption : round;\n  // allow for ZERO decimals\n  round = roundOption >= 0 ? roundOption : round;\n  // to round values to the power\n  // the `round` value must be integer\n  const pow = typeof round === 'number' && round >= 1 ? (10 ** round) : 1;\n\n  return path.map((pi) => {\n    const values = pi.slice(1).map(Number)\n      .map((n) => (round ? (Math.round(n * pow) / pow) : Math.round(n)));\n    return [pi[0], ...values];\n  });\n}\n\n/**\n * Returns a valid `d` attribute string value created\n * by rounding values and concatenating the `pathArray` segments.\n *\n * @param {SVGPath.pathArray} path the `pathArray` object\n * @param {number | 'off'} round amount of decimals to round values to\n * @returns {string} the concatenated path string\n */\nfunction pathToString(path, round) {\n  return roundPath(path, round)\n    .map((x) => x[0] + x.slice(1).join(' ')).join('');\n}\n\n/**\n * Split a path into an `Array` of sub-path strings.\n *\n * In the process, values are converted to absolute\n * for visual consistency.\n *\n * @param {SVGPath.pathArray} pathInput the source `pathArray`\n * @return {SVGPath.pathArray[]} an array with all sub-path strings\n */\nfunction splitPath(pathInput) {\n  /** @type {SVGPath.pathArray[]} */\n  const composite = [];\n  /** @type {SVGPath.pathArray} */\n  let path;\n  let pi = -1;\n\n  pathInput.forEach((seg) => {\n    if (seg[0] === 'M') {\n      path = [seg];\n      pi += 1;\n    } else {\n      path = [...path, seg];\n    }\n    composite[pi] = path;\n  });\n\n  return composite;\n}\n\n/**\n *\n * @param {{x: number, y: number}} v0\n * @param {{x: number, y: number}} v1\n * @returns {{x: number, y: number}}\n */\nfunction angleBetween(v0, v1) {\n  const { x: v0x, y: v0y } = v0;\n  const { x: v1x, y: v1y } = v1;\n  const p = v0x * v1x + v0y * v1y;\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\n  const angle = sign * Math.acos(p / n);\n\n  return angle;\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.\n * @see https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\n *\n * @param {number} x1 the starting x position\n * @param {number} y1 the starting y position\n * @param {number} RX x-radius of the arc\n * @param {number} RY y-radius of the arc\n * @param {number} angle x-axis-rotation of the arc\n * @param {number} LAF large-arc-flag of the arc\n * @param {number} SF sweep-flag of the arc\n * @param {number} x the ending x position\n * @param {number} y the ending y position\n * @param {number} t the point distance\n * @returns {{x: number, y: number}} the requested point\n */\nfunction getPointAtArcSegmentLength(x1, y1, RX, RY, angle, LAF, SF, x, y, t) {\n  const {\n    abs, sin, cos, sqrt, PI,\n  } = Math;\n  let rx = abs(RX);\n  let ry = abs(RY);\n  const xRot = ((angle % 360) + 360) % 360;\n  const xRotRad = xRot * (PI / 180);\n\n  if (x1 === x && y1 === y) {\n    return { x: x1, y: y1 };\n  }\n\n  if (rx === 0 || ry === 0) {\n    return segmentLineFactory(x1, y1, x, y, t).point;\n  }\n\n  const dx = (x1 - x) / 2;\n  const dy = (y1 - y) / 2;\n\n  const transformedPoint = {\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy,\n  };\n\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 + transformedPoint.y ** 2 / ry ** 2;\n\n  if (radiiCheck > 1) {\n    rx *= sqrt(radiiCheck);\n    ry *= sqrt(radiiCheck);\n  }\n\n  const cSquareNumerator = rx ** 2 * ry ** 2\n    - rx ** 2 * transformedPoint.y ** 2\n    - ry ** 2 * transformedPoint.x ** 2;\n\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2\n    + ry ** 2 * transformedPoint.x ** 2;\n\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * ((rx * transformedPoint.y) / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx),\n  };\n\n  const center = {\n    x: cos(xRotRad) * transformedCenter.x\n      - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,\n    y: sin(xRotRad) * transformedCenter.x\n      + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2,\n  };\n\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);\n\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!SF && sweepAngle > 0) {\n    sweepAngle -= 2 * PI;\n  } else if (SF && sweepAngle < 0) {\n    sweepAngle += 2 * PI;\n  }\n  sweepAngle %= 2 * PI;\n\n  const alpha = startAngle + sweepAngle * t;\n  const ellipseComponentX = rx * cos(alpha);\n  const ellipseComponentY = ry * sin(alpha);\n\n  const point = {\n    x: cos(xRotRad) * ellipseComponentX\n      - sin(xRotRad) * ellipseComponentY\n      + center.x,\n    y: sin(xRotRad) * ellipseComponentX\n      + cos(xRotRad) * ellipseComponentY\n      + center.y,\n  };\n\n  // to be used later\n  // point.ellipticalArcStartAngle = startAngle;\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\n  // point.ellipticalArcAngle = alpha;\n\n  // point.ellipticalArcCenter = center;\n  // point.resultantRx = rx;\n  // point.resultantRy = ry;\n\n  return point;\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the shape minimum and maximum {x,y} coordinates of an A (arc-to) segment.\n *\n * @param {number} X1 the starting x position\n * @param {number} Y1 the starting y position\n * @param {number} RX x-radius of the arc\n * @param {number} RY y-radius of the arc\n * @param {number} angle x-axis-rotation of the arc\n * @param {number} LAF large-arc-flag of the arc\n * @param {number} SF sweep-flag of the arc\n * @param {number} X2 the ending x position\n * @param {number} Y2 the ending y position\n * @param {number} distance the point distance\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentArcFactory(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, distance) {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = X1; let y = Y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y];\n  let t = 0;\n  let POINT = { x: 0, y: 0 };\n  let POINTS = [{ x, y }];\n\n  if (distanceIsNumber && distance <= 0) {\n    POINT = { x, y };\n  }\n\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n\n    ({ x, y } = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, t));\n    POINTS = [...POINTS, { x, y }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv,\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x: X2, y: Y2 };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map((n) => n.x)),\n      y: Math.min(...POINTS.map((n) => n.y)),\n    },\n    max: {\n      x: Math.max(...POINTS.map((n) => n.x)),\n      y: Math.max(...POINTS.map((n) => n.y)),\n    },\n  };\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} c1x the first control point X\n * @param {number} c1y the first control point Y\n * @param {number} c2x the second control point X\n * @param {number} c2y the second control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number} t a [0-1] ratio\n * @returns {{x: number, y: number}} the cubic-bezier segment length\n */\nfunction getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t) {\n  const t1 = 1 - t;\n  return {\n    x: (t1 ** 3) * x1\n      + 3 * (t1 ** 2) * t * c1x\n      + 3 * t1 * (t ** 2) * c2x\n      + (t ** 3) * x2,\n    y: (t1 ** 3) * y1\n      + 3 * (t1 ** 2) * t * c1y\n      + 3 * t1 * (t ** 2) * c2y\n      + (t ** 3) * y2,\n  };\n}\n\n/**\n * Returns the length of a C (cubic-bezier) segment\n * or an {x,y} point at a given length.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} c1x the first control point X\n * @param {number} c1y the first control point Y\n * @param {number} c2x the second control point X\n * @param {number} c2y the second control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number=} distance the point distance\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x2, y2, distance) {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = x1; let y = y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y];\n  let t = 0;\n  let POINT = { x: 0, y: 0 };\n  let POINTS = [{ x, y }];\n\n  if (distanceIsNumber && distance <= 0) {\n    POINT = { x, y };\n  }\n\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n\n    ({ x, y } = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t));\n    POINTS = [...POINTS, { x, y }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv,\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x: x2, y: y2 };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map((n) => n.x)),\n      y: Math.min(...POINTS.map((n) => n.y)),\n    },\n    max: {\n      x: Math.max(...POINTS.map((n) => n.x)),\n      y: Math.max(...POINTS.map((n) => n.y)),\n    },\n  };\n}\n\n/**\n * Returns the {x,y} coordinates of a point at a\n * given length of a quadratic-bezier segment.\n *\n * @see https://github.com/substack/point-at-length\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} cx the control point X\n * @param {number} cy the control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number} t a [0-1] ratio\n * @returns {{x: number, y: number}} the requested {x,y} coordinates\n */\nfunction getPointAtQuadSegmentLength(x1, y1, cx, cy, x2, y2, t) {\n  const t1 = 1 - t;\n  return {\n    x: (t1 ** 2) * x1\n      + 2 * t1 * t * cx\n      + (t ** 2) * x2,\n    y: (t1 ** 2) * y1\n      + 2 * t1 * t * cy\n      + (t ** 2) * y2,\n  };\n}\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a Q (quadratic-bezier) segment.\n *\n * @param {number} x1 the starting point X\n * @param {number} y1 the starting point Y\n * @param {number} qx the control point X\n * @param {number} qy the control point Y\n * @param {number} x2 the ending point X\n * @param {number} y2 the ending point Y\n * @param {number=} distance the distance to point\n * @returns {SVGPath.lengthFactory} the segment length, point, min & max\n */\nfunction segmentQuadFactory(x1, y1, qx, qy, x2, y2, distance) {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = x1; let y = y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y];\n  let t = 0;\n  let POINT = { x: 0, y: 0 };\n  let POINTS = [{ x, y }];\n\n  if (distanceIsNumber && distance <= 0) {\n    POINT = { x, y };\n  }\n\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n\n    ({ x, y } = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t));\n    POINTS = [...POINTS, { x, y }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv,\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  /* istanbul ignore else */\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x: x2, y: y2 };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map((n) => n.x)),\n      y: Math.min(...POINTS.map((n) => n.y)),\n    },\n    max: {\n      x: Math.max(...POINTS.map((n) => n.x)),\n      y: Math.max(...POINTS.map((n) => n.y)),\n    },\n  };\n}\n\n/**\n * Returns a {x,y} point at a given length\n * of a shape, the shape total length and\n * the shape minimum and maximum {x,y} coordinates.\n *\n * @param {string | SVGPath.pathArray} pathInput the `pathArray` to look into\n * @param {number=} distance the length of the shape to look at\n * @returns {SVGPath.lengthFactory} the path length, point, min & max\n */\nfunction pathLengthFactory(pathInput, distance) {\n  const path = normalizePath(pathInput);\n  const distanceIsNumber = typeof distance === 'number';\n  let isM;\n  let data = [];\n  let pathCommand;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let seg;\n  let MIN = [];\n  let MAX = [];\n  let length = 0;\n  let min = { x: 0, y: 0 };\n  let max = min;\n  let point = min;\n  let POINT = min;\n  let LENGTH = 0;\n\n  for (let i = 0, ll = path.length; i < ll; i += 1) {\n    seg = path[i];\n    [pathCommand] = seg;\n    isM = pathCommand === 'M';\n    data = !isM ? [x, y, ...seg.slice(1)] : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg;\n      min = { x: mx, y: my };\n      max = min;\n      length = 0;\n\n      if (distanceIsNumber && distance < 0.001) {\n        POINT = min;\n      }\n    } else if (pathCommand === 'L') {\n      ({\n        length, min, max, point,\n      } = segmentLineFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'A') {\n      ({\n        length, min, max, point,\n      } = segmentArcFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'C') {\n      ({\n        length, min, max, point,\n      } = segmentCubicFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'Q') {\n      ({\n        length, min, max, point,\n      } = segmentQuadFactory(...data, (distance || 0) - LENGTH));\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      ({\n        length, min, max, point,\n      } = segmentLineFactory(...data, (distance || 0) - LENGTH));\n    }\n\n    if (distanceIsNumber && LENGTH < distance && LENGTH + length >= distance) {\n      POINT = point;\n    }\n\n    MAX = [...MAX, max];\n    MIN = [...MIN, min];\n    LENGTH += length;\n\n    [x, y] = pathCommand !== 'Z' ? seg.slice(-2) : [mx, my];\n  }\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x, y };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...MIN.map((n) => n.x)),\n      y: Math.min(...MIN.map((n) => n.y)),\n    },\n    max: {\n      x: Math.max(...MAX.map((n) => n.x)),\n      y: Math.max(...MAX.map((n) => n.y)),\n    },\n  };\n}\n\n/**\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\n *\n * The `normalizePath` version is lighter, faster, more efficient and more accurate\n * with paths that are not `curveArray`.\n *\n * @param {string | SVGPath.pathArray} pathInput the target `pathArray`\n * @returns {number} the shape total length\n */\nfunction getTotalLength(pathInput) {\n  return pathLengthFactory(pathInput).length;\n}\n\n/**\n * Returns [x,y] coordinates of a point at a given length of a shape.\n *\n * @param {string | SVGPath.pathArray} pathInput the `pathArray` to look into\n * @param {number} distance the length of the shape to look at\n * @returns {{x: number, y: number}} the requested {x, y} point coordinates\n */\nfunction getPointAtLength(pathInput, distance) {\n  return pathLengthFactory(pathInput, distance).point;\n}\n\n/**\n * d3-polygon-area\n * https://github.com/d3/d3-polygon\n *\n * Returns the area of a polygon.\n *\n * @param {number[][]} polygon an array of coordinates\n * @returns {number} the polygon area\n */\nfunction polygonArea(polygon) {\n  const n = polygon.length;\n  let i = -1;\n  let a;\n  let b = polygon[n - 1];\n  let area = 0;\n\n  /* eslint-disable-next-line */\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n}\n\n/**\n * d3-polygon-length\n * https://github.com/d3/d3-polygon\n *\n * Returns the perimeter of a polygon.\n *\n * @param {[number,number][]} polygon an array of coordinates\n * @returns {number} the polygon length\n */\nfunction polygonLength(polygon) {\n  return polygon.reduce((length, point, i) => {\n    if (i) {\n      return length + distanceSquareRoot(polygon[i - 1], point);\n    }\n    return 0;\n  }, 0);\n}\n\n/**\n * A global namespace for epsilon.\n *\n * @type {number}\n */\nconst epsilon = 1e-9;\n\n/**\n * Coordinates Interpolation Function.\n *\n * @param {number[][]} a start coordinates\n * @param {number[][]} b end coordinates\n * @param {string} l amount of coordinates\n * @param {number} v progress\n * @returns {number[][]} the interpolated coordinates\n */\nfunction coords(a, b, l, v) {\n  const points = [];\n  for (let i = 0; i < l; i += 1) { // for each point\n    points[i] = [];\n    for (let j = 0; j < 2; j += 1) { // each point coordinate\n      // eslint-disable-next-line no-bitwise\n      points[i].push(((a[i][j] + (b[i][j] - a[i][j]) * v) * 1000 >> 0) / 1000);\n    }\n  }\n  return points;\n}\n\n/* SVGMorph = {\n  property: 'path',\n  defaultValue: [],\n  interpolators: {numbers,coords} },\n  functions = { prepareStart, prepareProperty, onStart, crossCheck }\n} */\n\n// Component functions\n/**\n * Sets the property update function.\n * @param {string} tweenProp the property name\n */\nfunction onStartSVGMorph(tweenProp) {\n  if (!KEC[tweenProp] && this.valuesEnd[tweenProp]) {\n    KEC[tweenProp] = (elem, a, b, v) => {\n      const path1 = a.polygon; const path2 = b.polygon;\n      const len = path2.length;\n      elem.setAttribute('d', (v === 1 ? b.original : `M${coords(path1, path2, len, v).join('L')}Z`));\n    };\n  }\n}\n\n// Component Util\n// original script flubber\n// https://github.com/veltman/flubber\n\n/**\n * Returns an existing polygon or false if it's not a polygon.\n * @param {SVGPath.pathArray} pathArray target `pathArray`\n * @returns {KUTE.exactPolygon | false} the resulted polygon\n */\nfunction exactPolygon(pathArray) {\n  const polygon = [];\n  const pathlen = pathArray.length;\n  let segment = [];\n  let pathCommand = '';\n\n  if (!pathArray.length || pathArray[0][0] !== 'M') {\n    return false;\n  }\n\n  for (let i = 0; i < pathlen; i += 1) {\n    segment = pathArray[i];\n    [pathCommand] = segment;\n\n    if ((pathCommand === 'M' && i) || pathCommand === 'Z') {\n      break; // !!\n    } else if ('ML'.includes(pathCommand)) {\n      polygon.push([segment[1], segment[2]]);\n    } else {\n      return false;\n    }\n  }\n\n  return pathlen ? { polygon } : false;\n}\n\n/**\n * Returns a new polygon polygon.\n * @param {SVGPath.pathArray} parsed target `pathArray`\n * @param {number} maxLength the maximum segment length\n * @returns {KUTE.exactPolygon} the resulted polygon\n */\nfunction approximatePolygon(parsed, maxLength) {\n  const ringPath = splitPath(parsed)[0];\n  const normalPath = normalizePath(ringPath);\n  const pathLength = getTotalLength(normalPath);\n  const polygon = [];\n  let numPoints = 3;\n  let point;\n\n  if (maxLength && !Number.isNaN(maxLength) && +maxLength > 0) {\n    numPoints = Math.max(numPoints, Math.ceil(pathLength / maxLength));\n  }\n\n  for (let i = 0; i < numPoints; i += 1) {\n    point = getPointAtLength(normalPath, (pathLength * i) / numPoints);\n    polygon.push([point.x, point.y]);\n  }\n\n  // Make all rings clockwise\n  if (polygonArea(polygon) > 0) {\n    polygon.reverse();\n  }\n\n  return {\n    polygon,\n    skipBisect: true,\n  };\n}\n\n/**\n * Parses a path string and returns a polygon array.\n * @param {string} str path string\n * @param {number} maxLength maximum amount of points\n * @returns {KUTE.exactPolygon} the polygon array we need\n */\nfunction pathStringToPolygon(str, maxLength) {\n  const parsed = normalizePath(str);\n  return exactPolygon(parsed) || approximatePolygon(parsed, maxLength);\n}\n\n/**\n * Rotates a polygon to better match its pair.\n * @param {KUTE.polygonMorph} polygon the target polygon\n * @param {KUTE.polygonMorph} vs the reference polygon\n */\nfunction rotatePolygon(polygon, vs) {\n  const len = polygon.length;\n  let min = Infinity;\n  let bestOffset;\n  let sumOfSquares = 0;\n  let spliced;\n  let d;\n  let p;\n\n  for (let offset = 0; offset < len; offset += 1) {\n    sumOfSquares = 0;\n\n    for (let i = 0; i < vs.length; i += 1) {\n      p = vs[i];\n      d = distanceSquareRoot(polygon[(offset + i) % len], p);\n      sumOfSquares += d * d;\n    }\n\n    if (sumOfSquares < min) {\n      min = sumOfSquares;\n      bestOffset = offset;\n    }\n  }\n\n  if (bestOffset) {\n    spliced = polygon.splice(0, bestOffset);\n    polygon.splice(polygon.length, 0, ...spliced);\n  }\n}\n\n/**\n * Sample additional points for a polygon to better match its pair.\n * @param {KUTE.polygonObject} polygon the target polygon\n * @param {number} numPoints the amount of points needed\n */\nfunction addPoints(polygon, numPoints) {\n  const desiredLength = polygon.length + numPoints;\n  const step = polygonLength(polygon) / numPoints;\n\n  let i = 0;\n  let cursor = 0;\n  let insertAt = step / 2;\n  let a;\n  let b;\n  let segment;\n\n  while (polygon.length < desiredLength) {\n    a = polygon[i];\n    b = polygon[(i + 1) % polygon.length];\n\n    segment = distanceSquareRoot(a, b);\n\n    if (insertAt <= cursor + segment) {\n      polygon.splice(i + 1, 0, segment\n        ? midPoint(a, b, (insertAt - cursor) / segment)\n        : a.slice(0));\n      insertAt += step;\n    } else {\n      cursor += segment;\n      i += 1;\n    }\n  }\n}\n\n/**\n * Split segments of a polygon until it reaches a certain\n * amount of points.\n * @param {number[][]} polygon the target polygon\n * @param {number} maxSegmentLength the maximum amount of points\n */\nfunction bisect(polygon, maxSegmentLength = Infinity) {\n  let a = [];\n  let b = [];\n\n  for (let i = 0; i < polygon.length; i += 1) {\n    a = polygon[i];\n    b = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];\n\n    // Could splice the whole set for a segment instead, but a bit messy\n    while (distanceSquareRoot(a, b) > maxSegmentLength) {\n      b = midPoint(a, b, 0.5);\n      polygon.splice(i + 1, 0, b);\n    }\n  }\n}\n\n/**\n * Checks the validity of a polygon.\n * @param {KUTE.polygonMorph} polygon the target polygon\n * @returns {boolean} the result of the check\n */\nfunction validPolygon(polygon) {\n  return Array.isArray(polygon)\n    && polygon.every((point) => Array.isArray(point)\n      && point.length === 2\n      && !Number.isNaN(point[0])\n      && !Number.isNaN(point[1]));\n}\n\n/**\n * Returns a new polygon and its length from string or another `Array`.\n * @param {KUTE.polygonMorph | string} input the target polygon\n * @param {number} maxSegmentLength the maximum amount of points\n * @returns {KUTE.polygonMorph} normalized polygon\n */\nfunction getPolygon(input, maxSegmentLength) {\n  let skipBisect;\n  let polygon;\n\n  if (typeof (input) === 'string') {\n    const converted = pathStringToPolygon(input, maxSegmentLength);\n    ({ polygon, skipBisect } = converted);\n  } else if (!Array.isArray(input)) {\n    throw Error(`${invalidPathValue}: ${input}`);\n  }\n\n  /** @type {KUTE.polygonMorph} */\n  const points = [...polygon];\n\n  if (!validPolygon(points)) {\n    throw Error(`${invalidPathValue}: ${points}`);\n  }\n\n  // TODO skip this test to avoid scale issues?\n  // Chosen epsilon (1e-6) is problematic for small coordinate range, we now use 1e-9\n  if (points.length > 1 && distanceSquareRoot(points[0], points[points.length - 1]) < epsilon) {\n    points.pop();\n  }\n\n  if (!skipBisect && maxSegmentLength\n    && !Number.isNaN(maxSegmentLength) && (+maxSegmentLength) > 0) {\n    bisect(points, maxSegmentLength);\n  }\n\n  return points;\n}\n\n/**\n * Returns two new polygons ready to tween.\n * @param {string} path1 the first path string\n * @param {string} path2 the second path string\n * @param {number} precision the morphPrecision option value\n * @returns {KUTE.polygonMorph[]} the two polygons\n */\nfunction getInterpolationPoints(path1, path2, precision) {\n  const morphPrecision = precision || defaultOptions$1.morphPrecision;\n  const fromRing = getPolygon(path1, morphPrecision);\n  const toRing = getPolygon(path2, morphPrecision);\n  const diff = fromRing.length - toRing.length;\n\n  addPoints(fromRing, diff < 0 ? diff * -1 : 0);\n  addPoints(toRing, diff > 0 ? diff : 0);\n\n  rotatePolygon(fromRing, toRing);\n\n  return [roundPath(fromRing), roundPath(toRing)];\n}\n\n// Component functions\n/**\n * Returns the current `d` attribute value.\n * @returns {string} the `d` attribute value\n */\nfunction getSVGMorph(/* tweenProp */) {\n  return this.element.getAttribute('d');\n}\n\n/**\n * Returns the property tween object.\n * @param {string} _ the property name\n * @param {string | KUTE.polygonObject} value the property value\n * @returns {KUTE.polygonObject} the property tween object\n */\nfunction prepareSVGMorph(/* tweenProp */_, value) {\n  const pathObject = {};\n  // remove newlines, they brake JSON strings sometimes\n  const pathReg = new RegExp('\\\\n', 'ig');\n  let elem = null;\n\n  if (value instanceof SVGPathElement) {\n    elem = value;\n  } else if (/^\\.|^#/.test(value)) {\n    elem = selector(value);\n  }\n\n  // first make sure we return pre-processed values\n  if (typeof (value) === 'object' && value.polygon) {\n    return value;\n  } if (elem && ['path', 'glyph'].includes(elem.tagName)) {\n    pathObject.original = elem.getAttribute('d').replace(pathReg, '');\n  // maybe it's a string path already\n  } else if (!elem && typeof (value) === 'string') {\n    pathObject.original = value.replace(pathReg, '');\n  }\n\n  return pathObject;\n}\n\n/**\n * Enables the `to()` method by preparing the tween object in advance.\n * @param {string} prop the `path` property name\n */\nfunction crossCheckSVGMorph(prop) {\n  if (this.valuesEnd[prop]) {\n    const pathArray1 = this.valuesStart[prop].polygon;\n    const pathArray2 = this.valuesEnd[prop].polygon;\n    // skip already processed paths\n    // allow the component to work with pre-processed values\n    if (!pathArray1 || !pathArray2 || (pathArray1.length !== pathArray2.length)) {\n      const p1 = this.valuesStart[prop].original;\n      const p2 = this.valuesEnd[prop].original;\n      // process morphPrecision\n      const morphPrecision = this._morphPrecision\n        ? parseInt(this._morphPrecision, 10)\n        : defaultOptions$1.morphPrecision;\n\n      const [path1, path2] = getInterpolationPoints(p1, p2, morphPrecision);\n      this.valuesStart[prop].polygon = path1;\n      this.valuesEnd[prop].polygon = path2;\n    }\n  }\n}\n\n// All Component Functions\nconst svgMorphFunctions = {\n  prepareStart: getSVGMorph,\n  prepareProperty: prepareSVGMorph,\n  onStart: onStartSVGMorph,\n  crossCheck: crossCheckSVGMorph,\n};\n\n// Component Full\nconst SVGMorph = {\n  component: 'svgMorph',\n  property: 'path',\n  defaultValue: [],\n  Interpolate: coords,\n  defaultOptions: { morphPrecision: 10 },\n  functions: svgMorphFunctions,\n  // Export utils to global for faster execution\n  Util: {\n    // component\n    addPoints,\n    bisect,\n    getPolygon,\n    validPolygon,\n    getInterpolationPoints,\n    pathStringToPolygon,\n    distanceSquareRoot,\n    midPoint,\n    approximatePolygon,\n    rotatePolygon,\n    // svg-path-commander\n    pathToString,\n    pathToCurve,\n    getTotalLength,\n    getPointAtLength,\n    polygonArea,\n    roundPath,\n  },\n};\n\nconst Components = {\n  EssentialBoxModel: BoxModelEssential,\n  ColorsProperties: colorProperties,\n  HTMLAttributes: htmlAttributes,\n  OpacityProperty,\n  TextWriteProp: TextWrite,\n  TransformFunctions,\n  SVGDraw: SvgDrawProperty,\n  SVGMorph,\n};\n\n// init components\nObject.keys(Components).forEach((component) => {\n  const compOps = Components[component];\n  Components[component] = new Animation(compOps);\n});\n\nvar version = \"2.2.4\";\n\n// @ts-ignore\n\n/**\n * A global namespace for library version.\n * @type {string}\n */\nconst Version = version;\n\n// KUTE.js standard distribution version\n\nconst KUTE = {\n  Animation,\n  Components,\n\n  // Tween Interface\n  Tween,\n  fromTo,\n  to,\n  // Tween Collection\n  TweenCollection,\n  allFromTo,\n  allTo,\n  // Tween Interface\n\n  Objects,\n  Util,\n  Easing,\n  CubicBezier,\n  Render,\n  Interpolate: interpolate,\n  Process,\n  Internals: internals,\n  Selector: selector,\n  Version,\n};\n\nexport { KUTE as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}